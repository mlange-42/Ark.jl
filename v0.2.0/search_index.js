var documenterSearchIndex = {"docs":
[{"location":"manual/entities.html#Entities","page":"Entities","title":"Entities","text":"Entities are the \"game objects\" or \"model entities\" in applications that use Ark. In effect, an entity is just an ID that can be associated with Components, which contain the entity's properties or state variables.","category":"section"},{"location":"manual/entities.html#creating-entities","page":"Entities","title":"Creating entities","text":"An entity can only exist in a World, and thus can only be created through a World.\n\nHere, we use new_entity! to create an entity with a Position and a Velocity components. Note that component values are passed as a tuple!\n\nentity = new_entity!(world, (\n    Position(100, 100),\n    Velocity(0, 0),\n))\n\nComponents can be added to and removed from the entity later. This is described in the next chapter.","category":"section"},{"location":"manual/entities.html#batch-entities","page":"Entities","title":"Batch creation","text":"Often, multiple entities with the same set of components are created at the same time. For that sake, Ark provides batch entity creation, which is much faster than creating entities one by one. There are different ways to create entities in batches:\n\nFrom default component values using new_entities!. Here, we create 100 entities, all with the same Position and Velocity:\n\nnew_entities!(world, 100, (\n    Position(100, 100),\n    Velocity(0, 0),\n))\n\nThis may be sufficient in some use cases, but most often we will use a second approach:\n\nFrom component types with subsequent manual initialization using new_entities! with a tuple of types:\n\nfor (entities, positions, velocities) in new_entities!(world, 100, (Position, Velocity))\n    for i in eachindex(entities)\n        positions[i] = Position(i, i)\n        velocities[i] = Velocity(0, 0)\n    end\nend\n\nThe nested loop shown here will be explained in detail in the chapter on Queries, which work in the same way as the Batch iterator that is returned from new_entities! and that is used here.\n\nNote that with the second approach, all components of all entities should be set as they are otherwise uninitialized.","category":"section"},{"location":"manual/entities.html#Removing-entities","page":"Entities","title":"Removing entities","text":"Removing an entity from the World is as simple as this, using remove_entity!:\n\nremove_entity!(world, entity)","category":"section"},{"location":"manual/entities.html#Alive-status","page":"Entities","title":"Alive status","text":"Entities can be safely stored, e.g. in the Components of other entities to represent relationships. However, as they may have been removed from the world elsewhere, it may be necessary to check whether an entity is still alive with is_alive:\n\nif is_alive(world, entity)\n    # ...\nend","category":"section"},{"location":"manual/entities.html#Zero-entity","page":"Entities","title":"Zero entity","text":"There is a reserved zero_entity that can be used as a placeholder for \"no entity\". The zero entity is never alive. The function is_zero can be used to determine whether an entity is the zero entity:\n\nif is_zero(entity)\n    # ...\nend","category":"section"},{"location":"manual/resources.html#Resources","page":"Resources","title":"Resources","text":"Resources are singular data structures in an ECS World. As such, they can be thought of as Components that exist only once and are not associated to an Entity. Examples could be the current game/simulation tick, a grid that your entities live on, or an acceleration structure for spatial indexing.","category":"section"},{"location":"manual/resources.html#Creating-resources","page":"Resources","title":"Creating resources","text":"Resources can be of any type, but only one resource of a particular type can exist in a World. They are simply added to the world with add_resource!:\n\nstruct Tick\n    time::Int\nend\n\nadd_resource!(world, Tick(0))","category":"section"},{"location":"manual/resources.html#Accessing-resources","page":"Resources","title":"Accessing resources","text":"Resources can be retrieved via get_resource:\n\ntick = get_resource(world, Tick)\ntime = tick.time\n\nAs getting a resource is not particularly fast (≈10ns), this should not be done in hot loops like queries, but beforehand.\n\nThe existence of a resource type in the World can be checked with has_resource:\n\nif has_resource(world, Tick)\n    # ...\nend","category":"section"},{"location":"manual/resources.html#Setting-and-removing-resources","page":"Resources","title":"Setting and removing resources","text":"Resources can also be removed from the world using remove_resource!, or overwritten with set_resource!, which is particularly useful for immutable types:\n\nset_resource!(world, Tick(1))\nremove_resource!(world, Tick)","category":"section"},{"location":"demos.html#Demos","page":"Demos","title":"Demos","text":"The Ark repository contains a number of runnable demos. These are listed here, alongside instructions for running them.","category":"section"},{"location":"demos.html#Running-a-demo","page":"Demos","title":"Running a demo","text":"<details>\n<summary><b>Click for instructions</b></summary>\n<br/>\n<p>\nFirst, clone the repository and `cd` into it:\n</p>\n\n<pre><code class=\"language-shell hljs\">git clone https://github.com/mlange-42/Ark.jl.git\ncd Ark.jl\n</code></pre>\n\n<p>\nNext, instantiate the demos project:\n</p>\n\n<pre><code class=\"language-shell hljs\">julia --project=demos -e 'using Pkg; Pkg.develop(path=\".\"); Pkg.instantiate()'\n</code></pre>\n\n<p>\nRun individual demos like this:\n</p>\n\n<pre><code class=\"language-shell hljs\">julia --project=demos demos/&lt;DEMO&gt;/main.jl\n</code></pre>\n\n<p>\nMost of the demos are interactive, so try hovering the mouse over the window.\n</p>\n\n</details>","category":"section"},{"location":"demos.html#Logo","page":"Demos","title":"Logo","text":"An animated, interactive Ark.jl logo. Use only the most basic features of Ark. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"Logo demo\" src=\"https://raw.githubusercontent.com/mlange-42/Ark.jl/refs/heads/gh-images/screenshots/logo.png\" />\n</div>","category":"section"},{"location":"demos.html#SIR","page":"Demos","title":"SIR","text":"A simple individual-based epidemiologic SIR model. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"SIR demo\" src=\"https://raw.githubusercontent.com/mlange-42/Ark.jl/refs/heads/gh-images/screenshots/sir.png\" />\n</div>","category":"section"},{"location":"demos.html#Boids","page":"Demos","title":"Boids","text":"Boids model, resembling bird flocks or fish schools. Makes use of entities stored in a spatial acceleration structure, as well as in components. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"SIR demo\" src=\"https://raw.githubusercontent.com/mlange-42/Ark.jl/refs/heads/gh-images/screenshots/boids.png\" />\n</div>","category":"section"},{"location":"demos.html#Network","page":"Demos","title":"Network","text":"Random travelers on a network. Makes massive use of entities stored in components. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"SIR demo\" src=\"https://raw.githubusercontent.com/mlange-42/Ark.jl/refs/heads/gh-images/screenshots/network.png\" />\n</div>","category":"section"},{"location":"demos.html#Grazers","page":"Demos","title":"Grazers","text":"An model for the evolution of the foraging behavior of grazers. Dynamically adds and removes components to handle behavioral states. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"SIR demo\" src=\"https://raw.githubusercontent.com/mlange-42/Ark.jl/refs/heads/gh-images/screenshots/grazers.png\" />\n</div>","category":"section"},{"location":"manual/events.html#Event-system","page":"Event system","title":"Event system","text":"Ark provides an event system with observers that allow an application to react on events, such as adding and removing components and entities.\n\nObservers can filter for the events they are interested in, in several ways. A callback function is executed for the affected entity whenever an observer's filter matches.\n\nIn addition to built-in lifecycle events like OnCreateEntity or OnAddComponents, Ark supports custom event types that enable domain-specific triggers. These events can be emitted manually and observed with the same filtering and callback mechanisms, making them ideal for modeling interactions such as user input, synchronization, or game logic.\n\nObservers are lightweight, composable, and follow the same declarative patterns as Ark’s query system. They provide fine-grained control over when and how logic is executed. This design encourages a declarative, data-driven approach while maintaining performance and flexibility.","category":"section"},{"location":"manual/events.html#Example","page":"Event system","title":"Example","text":"Use observe! to observe for events:\n\nobserve!(world, OnAddComponents, (Position, Velocity)) do entity\n    pos, vel = get_components(world, entity, (Position, Velocity))\n    println(pos)\n    println(vel)\nend\n\nentity = new_entity!(world, ())\nadd_components!(world, entity, (Position(0, 0), Velocity(1, 1)))","category":"section"},{"location":"manual/events.html#Event-types","page":"Event system","title":"Event types","text":"Observers are specific for different event types, and each observer can react only to one type. See below for how to react on multiple different types.\n\nOnCreateEntity: Emitted after a new entity is created.  \nOnRemoveEntity: Emitted before an entity is removed.\nOnAddComponents: Emitted after components are added to an existing entity.\nOnRemoveComponents: Emitted before components are removed from an entity.\n\nIf multiple components are added/removed for an entity, one event is emitted for the entire operation.","category":"section"},{"location":"manual/events.html#combining-types","page":"Event system","title":"Combining multiple types","text":"Observers can be combined to react to multiple event types in a single callback function. Below is a combination of observers to react on component addition as well as removal. The callback is set up to be able to distinguish between these event types (if needed).\n\nfn = (event::EventType, entity::Entity) -> begin\n    if event == OnAddComponents\n        println(\"Position added\")\n    elseif event == OnRemoveComponents\n        println(\"Position removed\")\n    end\nend\n\nobserve!(world, OnAddComponents, (Position,)) do entity\n    fn(OnAddComponents, entity)\nend\nobserve!(world, OnRemoveComponents, (Position,)) do entity\n    fn(OnRemoveComponents, entity)\nend","category":"section"},{"location":"manual/events.html#Filters","page":"Event system","title":"Filters","text":"Observers only trigger when all specified components (last non-keyword argument) are affected in a single operation. For example, if an observer watches Position and Velocity, both must be added or removed together for the observer to activate.\n\nFurther, events can be filtered by the composition of the affected entity via the keyword arguments with, without and exclusive, just like queries.\n\nFor entity creation and removal, only the keyword arguments can be used.\n\nExamples (leaving out observer registration):\n\nAn observer that is triggered when a Position component is added to an existing entity:\n\nobserve!(world, OnAddComponents, (Position,)) do entity\n    # ...\nend\n\nAn observer that is triggered when a Position component is added to an entity that has Velocity, but not Altitude (or rather, had before the operation):\n\nobserve!(world, OnAddComponents, (Position,);\n        with    = (Velocity,),\n        without = (Altitude,)\n    ) do entity\n    # ...\nend\n\nThis observer is triggered when an entity with Position is created:\n\nobserve!(world, OnCreateEntity;\n        with = (Velocity,)\n    ) do entity\n    # ...\nend\n\nThis observer is triggered when an entity with Position as well as Velocity is created:\n\nobserve!(world, OnCreateEntity;\n        with = (Position, Velocity)\n    ) do entity\n    # ...\nend\n\nAn observer that is triggered when any entity is created, irrespective of its components:\n\nobserve!(world, OnCreateEntity) do entity\n    # ...\nend","category":"section"},{"location":"manual/events.html#Event-timing","page":"Event system","title":"Event timing","text":"The time an event is emitted relative to the operation it is related to depends on the event's type. The observer callbacks are executed immediately by any emitted event.\n\nEvents for entity creation and for adding or setting components are emitted after the operation. Hence, the new or changed components can be inspected in the observer's callback. If emitted from individual operations, the world is in an unlocked state when the callback is executed. Contrary, when emitted from a batch operation, the world is locked.\n\nEvents for entity or component removal are emitted before the operation. This way, the entity or component to be removed can be inspected in the observer's callback. In this case, the world is locked when the callback is executed.\n\nNote that observer order is undefined. Observers are not necessarily triggered in the same order as they were registered.","category":"section"},{"location":"manual/events.html#custom-events","page":"Event system","title":"Custom events","text":"Custom events in Ark allow developers to define and emit their own event types, enabling application-specific logic such as UI interactions, game state changes, or other domain-specific triggers. These events support the same filtering and observer mechanisms as built-in events.\n\nDefine custom event types using an EventRegistry and neweventtype!:\n\n# Create an event registry\nregistry = EventRegistry()\n\n# Create event types\nconst OnCollisionDetected = new_event_type!(registry, :OnCollisionDetected)\nconst OnInputReceived     = new_event_type!(registry, :OnInputReceived)\nconst OnLevelLoaded       = new_event_type!(registry, :OnLevelLoaded)\nconst OnTimerElapsed      = new_event_type!(registry, :OnTimerElapsed)\n\nIdeally, custom event types are stored as global variables of the applications.\n\nUse emit_event! to emit custom events:\n\nregistry = EventRegistry()\nconst OnTeleport = new_event_type!(registry, :OnTeleport)\n\n# Add an observer for the event type\nobserve!(world, OnTeleport, (Position,)) do entity\n    # ...\nend\n\n# Emit the event for an entity and component type(s)\nemit_event!(world, OnTeleport, entity, (Position,))\n\nObservers might not be interested in components, or in more than one component. This is also supported by custom events:\n\nregistry = EventRegistry()\nconst OnClick = new_event_type!(registry, :OnClick)\n\nemit_event!(world, OnClick, ui_element)\n\nNote that custom events can also be emitted for the zero entity:\n\nregistry = EventRegistry()\nconst OnGameOver = new_event_type!(registry, :OnGameOver)\n\nemit_event!(world, OnGameOver, zero_entity)\n\nFor custom events, observer filters work exactly the same as for predefined events. The components in the last (optional) non-keyword argument are matched against the components of the event. with, without and exclusive are matched against the entity for which the event is emitted.","category":"section"},{"location":"manual/quickstart.html#Quickstart","page":"Quickstart","title":"Quickstart","text":"This page shows how to install Ark.jl, and gives a minimal usage example.\n\nFinally, it points into possible directions to continue.","category":"section"},{"location":"manual/quickstart.html#Installation","page":"Quickstart","title":"Installation","text":"Run this to add Ark.jl to a Julia project:\n\nusing Pkg\nPkg.add(\"Ark\")","category":"section"},{"location":"manual/quickstart.html#Example","page":"Quickstart","title":"Example","text":"Here is the classical Position/Velocity example that every ECS shows in the docs.\n\nRead the next chapters and view the API docs and demos for more details.\n\nusing Ark\n\n\"\"\"Position component\"\"\"\nstruct Position\n    x::Float64\n    y::Float64\nend\n\n\"\"\"Velocity component\"\"\"\nstruct Velocity\n    dx::Float64\n    dy::Float64\nend\n\n# Create a world with the required components\nworld = World(Position, Velocity)\n\nfor i in 1:1000\n    # Create an entity with components\n    entity = new_entity!(world, (Position(i, i * 2), Velocity(1, 1)))\nend\n\n# Time loop\nfor i in 1:10\n    # Iterate a query (archetypes)\n    for (entities, positions, velocities) in Query(world, (Position, Velocity))\n        # Iterate entities in the current archetype\n        @inbounds for i in eachindex(entities)\n            # Get components of the current entity\n            pos = positions[i]\n            vel = velocities[i]\n            # Update an (immutable) component\n            positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n        end\n    end\nend","category":"section"},{"location":"manual/quickstart.html#What's-next?","page":"Quickstart","title":"What's next?","text":"If you ask \"What is ECS?\", take a look at the great ECS FAQ by Sander Mertens, the author of the Flecs ECS.\n\nTo learn how to use Ark.jl, read the following chapters, browse the API documentation, or take a look at the GitHub repository.","category":"section"},{"location":"benchmarks.html#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"Several performance benchmarks for Ark.jl.\n\nMore to come soon...","category":"section"},{"location":"benchmarks.html#Ark-vs.-AoS","page":"Benchmarks","title":"Ark vs. AoS","text":"The figure below shows the classical Position/Velocity (movement system) benchmark, comparing Ark with the Array of Structs approach. Note that the data is from runs on the powerful GitHub CI machines. These have way more cache then consumer machines, where the performance advantage of Ark would be even more emphasized.\n\n<img src=\"assets/images/bench_aos_light.svg\" class=\"only-light\" alt=\"Benchmark vs. AoS\" />\n<img src=\"assets/images/bench_aos_dark.svg\" class=\"only-dark\" alt=\"Benchmark vs. AoS\" />\n\nArk vs. AoS: Legend entries denote the size of entities in bytes and in the number of Float64 fields.","category":"section"},{"location":"manual/systems.html#Systems","page":"Systems","title":"Systems","text":"Ark provides no systems as they are widely known in ECS implementations. This is a deliberate decision, based on these reasons:\n\nSystems can be hard to integrate into frameworks, like a game engine's update loop.   Ark wants to stay flexible and is completely engine-agnostic.\nSystems are usually tied to queries in a 1:1 relation, while it can be very useful to combine multiple queries.\nSystems and a scheduler are easy to implement, so this is left to the user.\n\nBelow, we provide an example for how to implement systems and a scheduler.","category":"section"},{"location":"manual/systems.html#Systems-example","page":"Systems","title":"Systems example","text":"","category":"section"},{"location":"manual/systems.html#sys-components","page":"Systems","title":"Components","text":"We start by defining our component types:\n\nusing Ark\n\nstruct Position\n    x::Float64\n    y::Float64\nend\nstruct Velocity\n    dx::Float64\n    dy::Float64\nend","category":"section"},{"location":"manual/systems.html#Abstract-system-type","page":"Systems","title":"Abstract system type","text":"We write an abstract system type. This is optional, but useful for clarity and to avoid boilerplate.\n\nabstract type System end\n\nfunction initialize!(::System, ::World) end\nfunction update!(::System, ::World) end\nfunction finalize!(::System, ::World) end","category":"section"},{"location":"manual/systems.html#Scheduler","page":"Systems","title":"Scheduler","text":"Next, we build a (type-stable) scheduler:\n\nstruct Scheduler{ST<:Tuple}\n    world::World\n    systems::ST\nend\n\nfunction run!(s::Scheduler, steps::Int)\n    # initialize all systems\n    for sys in s.systems\n        initialize!(sys, s.world)\n    end\n\n    # update loop\n    for _ in 1:steps\n        # update all systems\n        for sys in s.systems\n            update!(sys, s.world)\n        end\n    end\n    \n    # finalize all systems\n    for sys in s.systems\n        finalize!(sys, s.world)\n    end\nend","category":"section"},{"location":"manual/systems.html#Initializer-system","page":"Systems","title":"Initializer system","text":"Now we can write some systems. First one that creates some entities:\n\nstruct InitializerSystem <: System\n    count::Int\nend\n\nfunction initialize!(s::InitializerSystem, w::World)\n    for (entities, positions, velocities) in new_entities!(w, s.count, (Position, Velocity))\n        @inbounds for i in eachindex(entities)\n            positions[i] = Position(rand() * 100, rand() * 100)\n            velocities[i] = Velocity(randn(), randn())\n        end\n    end\nend\n\nAs we have the abstract type, we only need to implement the functions that are actually required for the system.","category":"section"},{"location":"manual/systems.html#Movement-system","page":"Systems","title":"Movement system","text":"And here the classical movement system:\n\nstruct MovementSystem <: System end\n\nfunction update!(s::InitializerSystem, w::World)\n    for (entities, positions, velocities) in Query(world, (Position, Velocity))\n        @inbounds for i in eachindex(entities)\n            pos = positions[i]\n            vel = velocities[i]\n            positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n        end\n    end\nend","category":"section"},{"location":"manual/systems.html#Putting-it-together","page":"Systems","title":"Putting it together","text":"Finally, we can plug everything together:\n\nworld = World(Position, Velocity)\n\nscheduler = Scheduler(\n    world,\n    (\n        InitializerSystem(100),\n        MovementSystem(),\n    ),\n)\n\nrun!(scheduler, 1000)","category":"section"},{"location":"manual/components.html#Components","page":"Components","title":"Components","text":"Components contain the data associated to an Entity, i.e. their properties or state variables.","category":"section"},{"location":"manual/components.html#Component-types","page":"Components","title":"Component types","text":"Components are distinguished by their type, and each entity can only have one component of a certain type.\n\nIn Ark, any type can be used as a component. However, it is highly recommended to use immutable types, because mutable objects are usually allocated on the heap in Julia, which defeats Ark's claim of high performance. Mutable types are disallowed by default, but can be enabled when constructing a World by the optional argument allow_mutable of the world constructor.","category":"section"},{"location":"manual/components.html#Accessing-components","page":"Components","title":"Accessing components","text":"Although the majority of the logic in an application that uses Ark will be performed in Queries, it may be necessary to access components for a particular entity. One or more components of an entity can be accessed via get_components:\n\n(pos, vel) = get_components(world, entity, (Position, Velocity))\n\nSimilarly, the components of an entity can be overwritten by new values via set_components!, which is particularly useful for immutable components (which are the default):\n\nset_components!(world, entity, (Position(0, 0), Velocity(1,1)))","category":"section"},{"location":"manual/components.html#Adding-and-removing-components","page":"Components","title":"Adding and removing components","text":"A feature that makes ECS particularly flexible and powerful is the ability to add components to and remove them from entities at runtime. This works similar to component access and can be done via add_components! and remove_components!:\n\nentity = new_entity!(world, ())\n\nadd_components!(world, entity, (Position(0, 0), Velocity(1,1)))\nremove_components!(world, entity, (Velocity,))\n\nNote that adding an already existing component or removing a missing one results in an error.\n\nAlso note that it is more efficient to add/remove multiple components at once instead of one by one. To allow for efficient exchange of components (i.e. add some and remove others in the same operation), exchange_components! can be used:\n\nentity = new_entity!(world, (Position(0, 0), Velocity(1,1)))\n\nexchange_components!(world, entity; \n    add    = (Health(100),),\n    remove = (Position, Velocity),\n)","category":"section"},{"location":"manual/components.html#component-storages","page":"Components","title":"Component storages","text":"Components are stored in archetypes, with the values for each component type stored in a separate array-like column. For these columns, Ark offers two storage modes:\n\nVector storage stores component objects in a simple vector per column. This is the default.\nStructArray storage stores components in an SoA data structure similar to   StructArrays.   This allows access to field vectors in queries, enabling SIMD-accelerated,   vectorized operations and increased cache-friendliness if not all of the component's fields are used.   StructArray storage has some limitations:  \nNot allowed for mutable components.\nNot allowed for components without fields, like labels and primitives.\n≈10-20% runtime overhead for component operations and entity creation.\nSlower component access with get_components and set_components!.\n\nThe storage mode can be selected per component type by using StructArrayStorage or VectorStorage during world construction.\n\nworld = World(\n    Position => VectorStorage,\n    Velocity => StructArrayStorage,\n)\n\nThe default is VectorStorage if no storage mode is specified:\n\nworld = World(\n    Position,\n    Velocity => StructArrayStorage,\n)","category":"section"},{"location":"api.html#API","page":"Public API","title":"API","text":"Ark's public API.\n\nPages = [\"api.md\"]\nDepth = 2:2","category":"section"},{"location":"api.html#world-api","page":"Public API","title":"World","text":"The World is the central data storage for Entities, Components and Resources.","category":"section"},{"location":"api.html#entities-api","page":"Public API","title":"Entities","text":"Entities are the \"game objects\" or \"model entities\". An entity if just an ID with a generation, but Components can be attached to an entity.","category":"section"},{"location":"api.html#components-api","page":"Public API","title":"Components","text":"Components contain the data associated with Entities.","category":"section"},{"location":"api.html#queries-api","page":"Public API","title":"Queries","text":"Queries are used to filter and process Entities with a certain set of Components.","category":"section"},{"location":"api.html#resources-api","page":"Public API","title":"Resources","text":"Resources are singleton-like data structures that appear only once in a World and are not associated to an Entity.","category":"section"},{"location":"api.html#batch-api","page":"Public API","title":"Batch","text":"An iterator over entities that were created or modified using batch operations. Behaves like a Query and can be used for component initialization.","category":"section"},{"location":"api.html#events-api","page":"Public API","title":"Event system","text":"The event system allows user code to react on structural changes like entity creation and removal and component addition and removal. Further, custom events can be defined and emitted.","category":"section"},{"location":"api.html#Index","page":"Public API","title":"Index","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api.html#Ark.World","page":"Public API","title":"Ark.World","text":"World{CS<:Tuple,CT<:Tuple,ST<:Tuple,N,M}\n\nThe World is the central storage for entities, components and resources.\n\nSee the constructor World for details.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.World-Tuple{Vararg{Type}}","page":"Public API","title":"Ark.World","text":"World(\n    comp_types::Type...;\n    initial_capacity::Int=128,\n    allow_mutable::Bool=false,\n)\n\nCreates a new, empty World for the given component types.\n\nAll component types that will be used with the world must be specified. This allows Ark to use Julia's compile-time method generation to achieve the best performance.\n\nFor each component type, an individual storage mode can be set. See also VectorStorage and StructArrayStorage.\n\nAdditional arguments can be used to allow mutable component types (forbidden by default and discouraged) and an initial capacity for entities in archetypes.\n\nArguments\n\ncomp_types: The component types used by the world.\ninitial_capacity: Initial capacity for entities in each archetype and in the entity index.\nallow_mutable: Allows mutable components. Use with care, as all mutable objects are heap-allocated in Julia.\n\nExamples\n\nA World where all components use the default storage mode:\n\nworld = World(\n    Position,\n    Velocity,\n)\n\nA World with individually configured storage modes:\n\nworld = World(\n    Position => StructArrayStorage,\n    Velocity => StructArrayStorage,\n    Health => VectorStorage,\n)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.reset!","page":"Public API","title":"Ark.reset!","text":"reset!(world::World)\n\nRemoves all entities and resources from the world, and un-registers all observers. Does NOT free reserved memory or remove archetypes.\n\nCan be used to run systematic simulations without the need to re-allocate memory for each run. Accelerates re-populating the world by a factor of 2-3.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.is_locked","page":"Public API","title":"Ark.is_locked","text":"is_locked(world::World)::Bool\n\nReturns whether the world is currently locked for modifications.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.StructArrayStorage","page":"Public API","title":"Ark.StructArrayStorage","text":"StructArrayStorage\n\nMarks component types for using StructArray-like storage mode in the world constructor.\n\nIn StructArray storages, mutable components are not allowed.\n\nSee also VectorStorage.\n\nExample\n\nworld = World(\n    Position => StructArrayStorage,\n    Velocity => StructArrayStorage,\n)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.VectorStorage","page":"Public API","title":"Ark.VectorStorage","text":"VectorStorage\n\nMarks component types for using Vector storage mode in the world constructor. As this is the default storage mode if the storage type is not specified.\n\nSee also StructArrayStorage.\n\nExample\n\nworld = World(\n    Position => VectorStorage,\n    Velocity => VectorStorage,\n)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.Entity","page":"Public API","title":"Ark.Entity","text":"Entity\n\nEntity identifier.\n\nEntities can be constructed using a World via new_entity!.\n\nEntities can be safely stored in components and resources.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.zero_entity","page":"Public API","title":"Ark.zero_entity","text":"const zero_entity::Entity\n\nThe reserved zero Entity value. Can be used to represent \"no entity\"/\"nil\".\n\n\n\n\n\n","category":"constant"},{"location":"api.html#Ark.new_entity!","page":"Public API","title":"Ark.new_entity!","text":"new_entity!(world::World, values::Tuple)::Entity\n\nCreates a new Entity with the given component values. Types are inferred from the values.\n\nExample\n\nentity = new_entity!(world, (Position(0, 0), Velocity(1, 1)))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.new_entities!","page":"Public API","title":"Ark.new_entities!","text":"new_entities!(world::World, n::Int, defaults::Tuple; iterate::Bool=false)::Union{Batch,Nothing}\n\nCreates the given number of Entity, initialized with default values. Component types are inferred from the provided default values.\n\nIf iterate is true, a Batch iterator over the newly created entities is returned that can be used for initialization.\n\nSee also new_entities! for creating entities from component types.\n\nArguments\n\nworld::World: The World instance to use.\nn::Int: The number of entities to create.\ndefaults::Tuple: A tuple of default values for initialization, like (Position(0, 0), Velocity(1, 1)).\niterate::Bool: Whether to return a batch for individual entity initialization.\n\nExamples\n\nCreate 100 entities from default values:\n\nnew_entities!(world, 100, (Position(0, 0), Velocity(1, 1)))\n\nCreate 100 entities from default values and iterate them:\n\nfor (entities, positions, velocities) in new_entities!(world, 100, (Position(0, 0), Velocity(1, 1)); iterate=true)\n    for i in eachindex(entities)\n        positions[i] = Position(rand(), rand())\n    end\nend\n\n\n\n\n\nnew_entities!(world::World, n::Int, comp_types::Tuple)::Batch\n\nCreates the given number of Entity.\n\nReturns a Batch iterator over the newly created entities that should be used to initialize components. Note that components are not initialized/undef unless set in the iterator!\n\nSee also new_entities! for creating entities from default values.\n\nArguments\n\nworld::World: The World instance to use.\nn::Int: The number of entities to create.\ncomp_types::Tuple: Component types for the new entities, like (Position, Velocity).\n\nExample\n\nCreate 100 entities from component types and initialize them:\n\nfor (entities, positions, velocities) in new_entities!(world, 100, (Position, Velocity))\n    for i in eachindex(entities)\n        positions[i] = Position(rand(), rand())\n        velocities[i] = Velocity(1, 1)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.remove_entity!","page":"Public API","title":"Ark.remove_entity!","text":"remove_entity!(world::World, entity::Entity)\n\nRemoves an Entity from the World.\n\nExample\n\nremove_entity!(world, entity)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.copy_entity!","page":"Public API","title":"Ark.copy_entity!","text":"copy_entity!(\n    world::World,\n    entity::Entity;\n    add::Tuple=(),\n    remove::Tuple=(),\n    mode=:copy,\n)\n\nCopies an Entity, optionally adding and/or removing components.\n\nMutable and non-isbits components are shallow copied by default. This can be changed with the mode argument.\n\nArguments\n\nworld: The World instance to query.\nentity::Entity: The entity to copy.\nadd::Tuple: Components to add, like with=(Health(0),).\nremove::Tuple: Component types to remove, like (Position,Velocity).\nmode::Tuple: Copy mode for mutable and non-isbits components. Modes are :ref, :copy, :deepcopy.\n\nExamples\n\nSimple copy of an entity:\n\nentity1 = copy_entity!(world, entity)\n\nCopy an entity, adding and removing some components in the same operation:\n\nentity2 = copy_entity!(world, entity;\n    add=(Health(100),),\n    remove=(Position, Velocity),\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.is_alive","page":"Public API","title":"Ark.is_alive","text":"is_alive(world::World, entity::Entity)::Bool\n\nReturns whether an Entity is alive.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.is_zero","page":"Public API","title":"Ark.is_zero","text":"is_zero(entity::Entity)::Bool\n\nReturns whether an Entity is the reserved zero_entity.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.get_components","page":"Public API","title":"Ark.get_components","text":"get_components(world::World, entity::Entity, comp_types::Tuple)\n\nGet the given components for an Entity. Components are returned in a tuple.\n\nExample\n\npos, vel = get_components(world, entity, (Position, Velocity))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.has_components","page":"Public API","title":"Ark.has_components","text":"has_components(world::World, entity::Entity, comp_types::Tuple)::Bool\n\nReturns whether an Entity has all given components.\n\nExample\n\nhas = has_components(world, entity, (Position, Velocity))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.set_components!","page":"Public API","title":"Ark.set_components!","text":"set_components!(world::World, entity::Entity, values::Tuple)\n\nSets the given component values for an Entity. Types are inferred from the values. The entity must already have all these components.\n\nExample\n\nset_components!(world, entity, (Position(0, 0), Velocity(1, 1)))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.add_components!","page":"Public API","title":"Ark.add_components!","text":"add_components!(world::World, entity::Entity, values::Tuple)\n\nAdds the given component values to an Entity. Types are inferred from the values.\n\nExample\n\nadd_components!(world, entity, (Health(100),))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.remove_components!","page":"Public API","title":"Ark.remove_components!","text":"remove_components!(world::World, entity::Entity, comp_types::Tuple)\n\nRemoves the given components from an Entity.\n\nExample\n\nremove_components!(world, entity, (Position, Velocity))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.exchange_components!","page":"Public API","title":"Ark.exchange_components!","text":"exchange_components!(world::World{CS,CT,N}, entity::Entity; add::Tuple, remove::Tuple)\n\nAdds and removes components on an Entity. Types are inferred from the add values.\n\nExample\n\nexchange_components!(world, entity;\n    add=(Health(100),),\n    remove=(Position, Velocity),\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.Query","page":"Public API","title":"Ark.Query","text":"Query\n\nA query for components. See function Query for details.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.Query-Tuple{World, Tuple}","page":"Public API","title":"Ark.Query","text":"Query(\n    world::World,\n    comp_types::Tuple;\n    with::Tuple=(),\n    without::Tuple=(),\n    optional::Tuple=(),\n    exclusive::Bool=false\n)\n\nCreates a query.\n\nA query is an iterator for processing all entities that match the query's criteria. The query itself iterates matching archetypes, while an inner loop or broadcast operations must be used to manipulate individual entities (see example below).\n\nA query locks the World until it is fully iterated or closed manually. This prevents structural changes like creating and removing entities or adding and removing components during the iteration.\n\nSee the user manual chapter on Queries for more details and examples.\n\nArguments\n\nworld: The World instance to query.\ncomp_types::Tuple: Components the query filters for and provides access to.\nwith::Tuple: Additional components the entities must have.\nwithout::Tuple: Components the entities must not have.\noptional::Tuple: Additional components that are optional in the query.\nexclusive::Bool: Makes the query exclusive in base and with components, can't be combined with without.\n\nExample\n\nfor (entities, positions, velocities) in Query(world, (Position, Velocity))\n    for i in eachindex(entities)\n        pos = positions[i]\n        vel = velocities[i]\n        positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.close!-Tuple{Query}","page":"Public API","title":"Ark.close!","text":"close!(q::Query)\n\nCloses the query and unlocks the world.\n\nMust be called if a query is not fully iterated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.count_entities-Tuple{Query}","page":"Public API","title":"Ark.count_entities","text":"count_entities(q::Query)\n\nReturns the number of matching entities in the query.\n\nDoes not iterate or close! the query.\n\nnote: Note\nThe time complexity is linear with the number of archetypes in the query's pre-selection. It is equivalent to iterating the query's archetypes and summing up their lengths.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.length-Tuple{Query}","page":"Public API","title":"Base.length","text":"length(q::Query)\n\nReturns the number of matching archetypes with at least one entity in the query.\n\nDoes not iterate or close! the query.\n\nnote: Note\nThe time complexity is linear with the number of archetypes in the query's pre-selection.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.Entities","page":"Public API","title":"Ark.Entities","text":"Entities\n\nArchetype column for entities. Can be iterated and indexed like a Vector.\n\nUsed in query iteration.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.@unpack","page":"Public API","title":"Ark.@unpack","text":"@unpack ...\n\nUnpacks the tuple returned from a Query during iteration into field vectors. Field vectors are particularly useful for StructArrayStorages, but can also be used with VectorStorages, although those are currently not equally efficient in broadcasted operations.\n\nColumns for components without fields, like primitives or label components, fall through @unpack unaltered.\n\nSee also unpack(::StructArrayView) and unpack(::FieldViewable).\n\nExample\n\nfor columns in Query(world, (Position, Velocity))\n    @unpack entities, (x, y), (dx, dy) = columns\n    @inbounds x .+= dx\n    @inbounds y .+= dy\nend\n\n\n\n\n\n","category":"macro"},{"location":"api.html#Ark.unpack","page":"Public API","title":"Ark.unpack","text":"unpack(a::StructArrayView)\n\nUnpacks the components (i.e. field vectors) of a StructArrayStorage column returned from a Query. See also @unpack.\n\n\n\n\n\nunpack(a::FieldViewable)\n\nUnpacks the components (i.e. field vectors) of a VectorStorage column returned from a Query. See also @unpack.\n\nnote: Note\nSetting values on unpacked non-isbits fields of immutable components has a certain overhead, as the underlying struct needs to be reconstructed and written to memory. See\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.get_resource","page":"Public API","title":"Ark.get_resource","text":"get_resource(world::World, res_type::Type{T})::T\n\nGet the resource of type T from the world.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.has_resource","page":"Public API","title":"Ark.has_resource","text":"has_resource(world::World, res_type::Type{T})::Bool\n\nCheck if a resource of type T is in the world.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.add_resource!","page":"Public API","title":"Ark.add_resource!","text":"add_resource!(world::World, res::T)::T\n\nAdd the given resource to the world. Returns the newly added resource.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.set_resource!","page":"Public API","title":"Ark.set_resource!","text":"set_resource!(world::World, res::T)::T\n\nOverwrites an existing resource in the world. Returns the newly overwritten resource.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.remove_resource!","page":"Public API","title":"Ark.remove_resource!","text":"remove_resource!(world::World, res_type::Type{T})::T\n\nRemove the resource of type T from the world. Returns the removed resource.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.Batch","page":"Public API","title":"Ark.Batch","text":"Batch\n\nA batch iterator. This is returned from batch operations and serves for initializing newly added components or otherwise processing the manipulated entities.\n\nThe batch itself iterates matching archetypes just like a Query, while an inner loop or broadcast operations must be used to manipulate individual entities.\n\nA batch locks the World until it is fully iterated or closed manually. This prevents structural changes like creating and removing entities or adding and removing components during the iteration.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.close!-Tuple{Batch}","page":"Public API","title":"Ark.close!","text":"close!(b::Batch)\n\nCloses the batch iterator and unlocks the world.\n\nMust be called if a batch is not fully iterated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.count_entities-Tuple{Batch}","page":"Public API","title":"Ark.count_entities","text":"count_entities(b::Batch)\n\nReturns the number of entities in the batch.\n\nDoes not iterate or close! the batch.\n\nnote: Note\nThe time complexity is linear with the number of archetypes in the batch. For batch entity creation, the number of archetype is always 1.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.length-Tuple{Batch}","page":"Public API","title":"Base.length","text":"length(b::Batch)\n\nReturns the number of archetypes in the batch. For batch entity creation, the number of archetype is always 1.\n\nDoes not iterate or close! the batch.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.EventType","page":"Public API","title":"Ark.EventType","text":"EventType\n\nType for built-in and custom events. See EventRegistry for creating custom event types.\n\nBuilt-in event types\n\nOnCreateEntity: Event emitted when a new entity is created.\nOnRemoveEntity: Event emitted when an entity is removed from the World.\nOnAddComponents: Event emitted when components are added to an entity.\nOnRemoveComponents: Event emitted when components are removed from an entity.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.EventRegistry","page":"Public API","title":"Ark.EventRegistry","text":"EventRegistry\n\nServes for creating custom event types.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.EventRegistry-Tuple{}","page":"Public API","title":"Ark.EventRegistry","text":"EventRegistry()\n\nCreates a new EventRegistry.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.new_event_type!","page":"Public API","title":"Ark.new_event_type!","text":"new_event_type!(reg::EventRegistry, symbol::Symbol)\n\nCreates a new custom EventType. Custom event types are best stored in global constants.\n\nThe symbol is only used for printing.\n\nExample\n\nregistry = EventRegistry()\nconst OnGameOver = new_event_type!(registry, :OnGameOver)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.Observer","page":"Public API","title":"Ark.Observer","text":"Observer\n\nObserver for reacting on built-in and custom events.\n\nSee observe! for details. See EventType for built-in, and EventRegistry for custom event types.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.observe!","page":"Public API","title":"Ark.observe!","text":"observe!(\n    fn::Function,\n    world::World,\n    event::EventType,\n    components::Tuple=();\n    with::Tuple=(),\n    without::Tuple=(),\n    exclusive::Bool=false,\n    register::Bool=true,\n)\n\nCreates an Observer and (optionally, default) registers it.\n\nSee EventType for built-in, and EventRegistry for custom event types.\n\nArguments\n\nfn::Function: A callback function to execute when a matching event is received. Can be used via a do block.\nworld::World: The World to observe.\nevent::EventType: The EventType to observe.\ncomponents::Tuple=(): The component types to observe. Must be empty for OnCreateEntity and OnRemoveEntity.\nwith::Tuple=(): Components the entity must have.\nwithout::Tuple=(): Components the entity must not have.\nexclusive::Bool=false: Makes the observer exclusive for entities that have exactly the components given be with.\nregister::Bool=true: Whether the observer is registered immediately. Alternatively, register later with observe!\n\nExample\n\nobserve!(world, OnAddComponents, (Position, Velocity); with=(Altitude,)) do entity\n    println(entity)\nend\n\n\n\n\n\nobserve!(world::World, observer::Observer; unregister::Bool=false)\n\nRegisters or un-registers the given Observer. Note that observers created with observe! are automatically registered by default.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.emit_event!","page":"Public API","title":"Ark.emit_event!","text":"emit_event!(world::World, event::EventType, entity::Entity, components::Tuple=())\n\nEmits a custom event for the given EventType, Entity and optional components. The entity must have the given components. The entity can be the reserved zero_entity.\n\nworld::World: The World to emit the event.\nevent::EventType: The EventType to emit.\nentity::Entity: The Entity to emit the event for.\ncomponents::Tuple=(): The component types to emit the event for. Optional.\n\nExample\n\nemit_event!(world, OnCollisionDetected, entity, (Position, Velocity))\n\n\n\n\n\n","category":"function"},{"location":"manual/queries.html#Queries","page":"Queries","title":"Queries","text":"Queries allow to select Entities that have a certain set of Components and to manipulate them.\n\nQueries are the heart of every ECS and the main reason for its flexibility and performance. In Ark, queries are blazing fast and should be used to write the game or model logic where possible. For cases where components of a particular entity are required, see section Accessing components.","category":"section"},{"location":"manual/queries.html#Basic-queries","page":"Queries","title":"Basic queries","text":"By default, a Query iterates over all entities that have the query's components, and provides efficient access to these components.\n\nHere, we are interested only in non-exclusive sets. So the entities that are processed may have further components, but these are not of interest for that particular piece of game or model logic.\n\nfor (entities, positions, velocities) in Query(world, (Position, Velocity))\n    @inbounds for i in eachindex(entities)\n        pos = positions[i]\n        vel = velocities[i]\n        positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n    end\nend\n\nNote the nested loop! In the outer loop, the query iterates the archetypes, and for each one returns a vector of entities and the columns for the queried components. In the inner loop, we iterate over the entities within the archetype and perform the actual logic.\n\nAlso note the last line in the inner loop. Here, we assign a new Position value to the current entity. This is necessary as Position is immutable, which is the default and highly recommended. See section Component types for details.\n\nThe @inbounds macro in front of the inner loop is optional, but it is safe to use here and makes the iteration faster as it allows the compiler to skip bounds checks.","category":"section"},{"location":"manual/queries.html#Advanced-queries","page":"Queries","title":"Advanced queries","text":"Query filters can be configured further, to include or exclude additional components.","category":"section"},{"location":"manual/queries.html#with","page":"Queries","title":"with","text":"Queries provide an optional with argument that filters for additional components that entities must have, but that are not used by the query.\n\nfor (entities, positions, velocities) in Query(world,\n            (Position, Velocity);\n            with=(Health,)\n        )\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"section"},{"location":"manual/queries.html#without","page":"Queries","title":"without","text":"The optional without argument allows to exclude entities that have certain components:\n\nfor (entities, positions, velocities) in Query(world,\n            (Position, Velocity);\n            without=(Health,)\n        )\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"section"},{"location":"manual/queries.html#exclusive","page":"Queries","title":"exclusive","text":"The optional exclusive argument excludes entities that have any other then the query's components and those specified by with. So it acts like an exhaustive without:\n\nfor (entities, positions, velocities) in Query(world,\n            (Position, Velocity);\n            exclusive=true\n        )\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"section"},{"location":"manual/queries.html#optional","page":"Queries","title":"optional","text":"The optional optional argument adds optional component. 😉\n\nEntities are included irrespective of presence of these components on them. Columns for these components are added at the end of the query iterator tuple. They are nothing if the current archetype does not have them.\n\nfor (entities, positions, velocities, healths) in Query(world,\n            (Position, Velocity);\n            optional=(Health,)\n        )\n    has_healths = healths !== nothing\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend\n\nNote that it is possible to branch already outside of the inner loop, as all entities in an archetype either have a component or don't.","category":"section"},{"location":"manual/queries.html#Component-field-views","page":"Queries","title":"Component field views","text":"Individual fields of components can be accessed as vectors in queries, e.g. using @unpack. This is particularly useful for components that use the StructArray storage modes, as it allows for SIMD-accelerated vectorized operations.\n\nworld = World(\n    Position => StructArrayStorage,\n    Velocity => StructArrayStorage,\n)\n\n# ...\n\nfor columns in Query(world, (Position, Velocity))\n    @unpack entities, (x, y), (dx, sy) = columns\n    @inbounds x .+= dx\n    @inbounds y .+= dy\nend\n\nHowever, when iterating components that use StructArray storage without unpacking individual fields, there is a certain overhead and SIMD optimization may not be possible.\n\nNote that it is also possible to access field vectors by the field's name:\n\nfor (_, positions, velocities) in Query(world, (Position, Velocity))\n    @inbounds positions.x .+= velocities.dx\n    @inbounds positions.y .+= velocities.dy\nend","category":"section"},{"location":"manual/queries.html#world-lock","page":"Queries","title":"World lock","text":"During query iteration, the World is locked for modifications like entity creation and removal and component addition and removal. This is necessary to prevent changes to the inner storage structure of the World that would result in undefined behavior of the query.\n\nWhenever the game or model logic demands one of these forbidden operations, the entities to be affected must first be collected into a Vector, and the operations must be applied only after the query iteration has finished.\n\n# vector for entities to be removed from te world\nto_remove = Entity[]\n\nfor (entities, positions) in Query(world, (Position,))\n    @inbounds for i in eachindex(entities)\n        pos = positions[i]\n\n        # collect entities for removal\n        if pos.y < 0\n            push!(to_remove, entities[i])\n        end\n    end\nend\n\n# actual removal\nfor entity in to_remove\n    remove_entity!(world, entity)\nend\n\n# clear the vector for re-use\nresize!(to_remove, 0)\n\nFor the best performance, such a Vector should be stored persistently and re-used to avoid repeated memory allocations.\n\nThe world is automatically unlocked when query iteration finishes. When breaking out of a query loop, however, it must be unlocked by calling close! on the query.","category":"section"},{"location":"manual/world.html#The-World","page":"The World","title":"The World","text":"A World is the central data store for any application that uses Ark.jl. It manages Entities, Components and Resources, and all these are always tied to a World.\n\nMost applications will have exactly one world, but multiple worlds can exist at the same time.","category":"section"},{"location":"manual/world.html#World-creation","page":"The World","title":"World creation","text":"When creating a new world, all Component types that can exist in it must be specified.\n\nusing Ark\n\nstruct Position\n    x::Float64\n    y::Float64\nend\n\nstruct Velocity\n    dx::Float64\n    dy::Float64\nend\n\nworld = World(Position, Velocity)\n\nThis may seem unusual, but it allows Ark to leverage Julia's compile-time programming features for the best performance.","category":"section"},{"location":"manual/world.html#Initial-capacity","page":"The World","title":"Initial capacity","text":"The World constructor takes an option keyword argument initial_capacity to allocate memory for the given number of entities in each archetype. This is useful to speed up entity creations by avoiding repeated allocations.\n\nworld = World(Position, Velocity; initial_capacity=1024)","category":"section"},{"location":"manual/world.html#World-reset","page":"The World","title":"World reset","text":"Ark's primary goal is to empower high-performance simulation models. In this domain, it is common to run large numbers of simulations, whether to explore model stochasticity, perform calibration, or for optimization purposes.\n\nTo maximize efficiency, Ark provides a reset! function that resets a simulation world for subsequent reuse. This significantly accelerates model initialization by reusing already allocated memory and avoiding costly reallocation.\n\nreset!(world)","category":"section"},{"location":"manual/world.html#World-functionality","page":"The World","title":"World functionality","text":"You will see that almost all methods in Ark's API take a World as their first argument. These methods are explained in the following chapters.","category":"section"},{"location":"manual/architecture.html#Architecture","page":"Architecture","title":"Architecture","text":"This chapter describes the principles of Ark's architecture, which may be useful to understand what is actually going on, and to understand performance trade-offs.\n\nFor now, see chapter Architecture of the Go ECS Ark, which Arks.jl is a port of.\n\nTODO","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"<div style=\"text-align: center;\">\n\n<img src=\"assets/ark-logo-text-light.svg\" class=\"only-light\" alt=\"Ark.jl (logo)\" />\n<img src=\"assets/ark-logo-text-dark.svg\" class=\"only-dark\" alt=\"Ark.jl (logo)\" />\n\n(Image: Build Status) (Image: Coverage) (Image: Aqua QA) (Image: JET) (Image: Docs stable) (Image: Docs dev) (Image: GitHub) (Image: DOI:10.5281/zenodo.17512271) (Image: MIT license) (Image: Apache 2.0 license)\n\nArk.jl is an archetype-based Entity Component System (ECS) for Julia. It is a port of the Go ECS Ark.\n\n&mdash;&mdash;\n</div>","category":"section"},{"location":"index.html#Features","page":"Home","title":"Features","text":"Designed for performance and highly optimized.\nWell-documented, type-stable API.\nExtensible event system with filtering and custom event types.\nStorage mode per component for ergonomics and SIMD.\nBlazing fast batch entity creation.\nNo systems. Just queries. Use your own structure.\nMinimal dependencies, 100% test coverage.","category":"section"},{"location":"index.html#Why-ECS?","page":"Home","title":"Why ECS?","text":"Entity Component Systems (ECS) offer a clean, scalable way to build individual- and agent-based models by separating agent data from behavioral logic. Agents are simply collections of components, while systems define how those components interact, making simulations modular, extensible, and efficient even with millions of heterogeneous individuals.\n\nArk.jl brings this architecture to Julia with a lightweight, performance-focused implementation that empowers scientific modellers to design complex and performant simulations without the need for deep software engineering expertise.","category":"section"},{"location":"index.html#Manual-Outline","page":"Home","title":"Manual Outline","text":"Quickstart\nThe World\nEntities\nComponents\nQueries\nSystems\nResources\nEvent system\nArchitecture\n\nDemos\n\nBenchmarks","category":"section"},{"location":"index.html#API-Outline","page":"Home","title":"API Outline","text":"Pages = [\"api.md\"]\nDepth = 2:2","category":"section"},{"location":"index.html#API-Index","page":"Home","title":"API Index","text":"Pages = [\"api.md\"]","category":"section"},{"location":"index.html#Cite-as","page":"Home","title":"Cite as","text":"Lange, M. & Meligrana, A. (2025): Ark.jl – An archetype-based Entity Component System for Julia. DOI: 10.5281/zenodo.17512271, GitHub repository: https://github.com/mlange-42/Ark.jl","category":"section"}]
}
