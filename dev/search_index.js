var documenterSearchIndex = {"docs":
[{"location":"manual/entities.html#Entities","page":"Entities","title":"Entities","text":"","category":"section"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"Entities are the \"game objects\" or \"model entities\" in applications that use Ark. In effect, an entity is just an ID that can be associated with Components, which contain the entity's properties or state variables.","category":"page"},{"location":"manual/entities.html#creating-entities","page":"Entities","title":"Creating entities","text":"","category":"section"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"An entity can only exist in a World, and thus can only be created through a World.","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"Here, we use new_entity! to create an entity with a Position and a Velocity components. Note that component values are passed as a tuple!","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"entity = new_entity!(world, (\n    Position(100, 100),\n    Velocity(0, 0),\n))","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"Components can be added to and removed from the entity later. This is described in the next chapter.","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"Often, multiple entities with the same same set of components are created at the same time. For that sake, Ark provides batch entity creation, which is much faster than creating entities one by one. There are different ways to create entities in batches:","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"From default component values using new_entities!. Here, we create 100 entities, all with the same Position and Velocity:","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"new_entities!(world, 100, (\n    Position(100, 100),\n    Velocity(0, 0),\n))","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"This may be sufficient in some use cases, but most often we will use a second approach:","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"From component types with subsequent manual initialization using the macro @new_entities!:","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"for (entities, positions, velocities) in @new_entities!(world, 100, (Position, Velocity))\n    for i in eachindex(entities)\n        positions[i] = Position(i, i)\n        velocities[i] = Velocity(0, 0)\n    end\nend","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"The nested loop shown here will be explained in detail in the chapter on Queries, which work in the same way at the Batch iterator that is returned from @new_entities! and that is used here.","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"Note that with the second approach, all components of all entities should be set as they are otherwise uninitialized.","category":"page"},{"location":"manual/entities.html#Removing-entities","page":"Entities","title":"Removing entities","text":"","category":"section"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"Removing an entity from the World is as easy as this:","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"remove_entity!(world, entity)","category":"page"},{"location":"manual/entities.html#Alive-status","page":"Entities","title":"Alive status","text":"","category":"section"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"Entities can be safely stored, e.g. in the Components of other entities to represent relationships. However, as they may have been removed from the world elsewhere, it may be necessary to check whether an entity is still alive:","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"if is_alive(world, entity)\n    # ...\nend","category":"page"},{"location":"manual/entities.html#Zero-entity","page":"Entities","title":"Zero entity","text":"","category":"section"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"There is a reserved zero_entity that can be used as a placeholder for \"no entity\". The zero entity is never alive. the function is_zero can be used to determine whether an entity is the zero entity:","category":"page"},{"location":"manual/entities.html","page":"Entities","title":"Entities","text":"if is_zero(entity)\n    # ...\nend","category":"page"},{"location":"manual/resources.html#Resources","page":"Resources","title":"Resources","text":"","category":"section"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"Resources are singular data structures in an ECS World. As such, they can be thought of as Components that exist only once and are not associated to an Entity. Examples could be the current game/simulation tick, a grid that your entities live on, or an acceleration structure for spatial indexing.","category":"page"},{"location":"manual/resources.html#Creating-resources","page":"Resources","title":"Creating resources","text":"","category":"section"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"Resources can be of any type, but only one resource of a particular type can exist in a World. They are simply added to the world with add_resource!:","category":"page"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"struct Tick\n    time::Int\nend\n\nadd_resource!(world, Tick(0))","category":"page"},{"location":"manual/resources.html#Accessing-resources","page":"Resources","title":"Accessing resources","text":"","category":"section"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"Resources can be retrieved via get_resource:","category":"page"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"tick = get_resource(world, Tick)\ntime = tick.time","category":"page"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"As getting a resource is not particularly fast (10-15ns), this should not be done in hot loops like queries, but beforehand.","category":"page"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"The existence of a resource type in the World can be checked with has_resource:","category":"page"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"if has_resource(world, Tick)\n    # ...\nend","category":"page"},{"location":"manual/resources.html#Setting-and-removing-resources","page":"Resources","title":"Setting and removing resources","text":"","category":"section"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"Resources can also be removed from the world using remove_resource!, or overwritten with set_resource!, which is particularly useful for immutable types:","category":"page"},{"location":"manual/resources.html","page":"Resources","title":"Resources","text":"set_resource!(world, Tick(1))\nremove_resource!(world, Tick)","category":"page"},{"location":"manual/quickstart.html#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"manual/quickstart.html","page":"Quickstart","title":"Quickstart","text":"This page shows how to install Ark.jl, and gives a minimal usage example.","category":"page"},{"location":"manual/quickstart.html","page":"Quickstart","title":"Quickstart","text":"Finally, it points into possible directions to continue.","category":"page"},{"location":"manual/quickstart.html#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"manual/quickstart.html","page":"Quickstart","title":"Quickstart","text":"Ark.jl is not yet released. For now, run this in your project to use it:","category":"page"},{"location":"manual/quickstart.html","page":"Quickstart","title":"Quickstart","text":"using Pkg\nPkg.add(url=\"https://github.com/mlange-42/ark.jl\")","category":"page"},{"location":"manual/quickstart.html#Example","page":"Quickstart","title":"Example","text":"","category":"section"},{"location":"manual/quickstart.html","page":"Quickstart","title":"Quickstart","text":"Here is the classical Position/Velocity example that every ECS shows in the docs.","category":"page"},{"location":"manual/quickstart.html","page":"Quickstart","title":"Quickstart","text":"using Ark\n\n\"\"\"Position component\"\"\"\nstruct Position\n    x::Float64\n    y::Float64\nend\n\n\"\"\"Velocity component\"\"\"\nstruct Velocity\n    dx::Float64\n    dy::Float64\nend\n\n# Create a world with the required components\nworld = World(Position, Velocity)\n\nfor i in 1:1000\n    # Create an entity with components\n    entity = new_entity!(world, (Position(i, i * 2), Velocity(1, 1)))\nend\n\n# Time loop\nfor i in 1:10\n    # Iterate a query (archetypes)\n    for (entities, positions, velocities) in @Query(world, (Position, Velocity))\n        # Iterate entities in the current archetype\n        @inbounds for i in eachindex(entities)\n            # Get components of the current entity\n            pos = positions[i]\n            vel = velocities[i]\n            # Update an (immutable) component\n            positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n        end\n    end\nend","category":"page"},{"location":"manual/quickstart.html#What's-next?","page":"Quickstart","title":"What's next?","text":"","category":"section"},{"location":"manual/quickstart.html","page":"Quickstart","title":"Quickstart","text":"If you ask \"What is ECS?\", take a look at the great ECS FAQ by Sander Mertens, the author of the Flecs ECS.","category":"page"},{"location":"manual/quickstart.html","page":"Quickstart","title":"Quickstart","text":"To learn how to use Ark.jl, read the following chapters, browse the API documentation, or take a look at the GitHub repository.","category":"page"},{"location":"benchmarks.html#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks.html","page":"Benchmarks","title":"Benchmarks","text":"Several performance benchmarks for Ark.jl.","category":"page"},{"location":"benchmarks.html","page":"Benchmarks","title":"Benchmarks","text":"More to come soon...","category":"page"},{"location":"benchmarks.html#Ark-vs.-AoS","page":"Benchmarks","title":"Ark vs. AoS","text":"","category":"section"},{"location":"benchmarks.html","page":"Benchmarks","title":"Benchmarks","text":"The figure below shows the classical Position/Velocity (movement system) benchmark, comparing Ark with the Array of Structs approach. Note that the data is from runs on the powerful GitHub CI machines. These have way more cache then consumer machines, where the performance advantage of Ark would be even more emphasized.","category":"page"},{"location":"benchmarks.html","page":"Benchmarks","title":"Benchmarks","text":"<img src=\"assets/images/bench_aos_light.svg\" class=\"only-light\" alt=\"Benchmark vs. AoS\" />\n<img src=\"assets/images/bench_aos_dark.svg\" class=\"only-dark\" alt=\"Benchmark vs. AoS\" />","category":"page"},{"location":"benchmarks.html","page":"Benchmarks","title":"Benchmarks","text":"Ark vs. AoS: Legend entries denote the size of entities in bytes and in the number of Float64 fields.","category":"page"},{"location":"manual/systems.html#Systems","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"Ark provides no systems as they are widely known in ECS implementations. This is a deliberate decisions, based on these reasons:","category":"page"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"Systems can be hard to integrate into frameworks, like a game engine's update loop.   Ark wants to stay flexible and is completely engine-agnostic.\nSystems are usually tied to queries in a 1:1 relation, while it is easily possible to combine multiple queries.\nSystems and a scheduler are easy to implement, so this is left to the user.","category":"page"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"Below, we provide an example for how to implement systems and a scheduler.","category":"page"},{"location":"manual/systems.html#Systems-example","page":"Systems","title":"Systems example","text":"","category":"section"},{"location":"manual/systems.html#sys-components","page":"Systems","title":"Components","text":"","category":"section"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"We start by defining our component types:","category":"page"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"using Ark\n\nstruct Position\n    x::Float64\n    y::Float64\nend\nstruct Velocity\n    dx::Float64\n    dy::Float64\nend","category":"page"},{"location":"manual/systems.html#Abstract-system-type","page":"Systems","title":"Abstract system type","text":"","category":"section"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"We write and abstract system type. This is optional, but useful for clarity and to avoid boilerplate.","category":"page"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"abstract type System end\n\nfunction initialize!(::System, ::World) end\nfunction update!(::System, ::World) end\nfunction finalize!(::System, ::World) end","category":"page"},{"location":"manual/systems.html#Scheduler","page":"Systems","title":"Scheduler","text":"","category":"section"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"Next, we build a (type-stable) scheduler:","category":"page"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"struct Scheduler{ST<:Tuple}\n    world::World\n    systems::ST\nend\n\nfunction run!(s::Scheduler, steps::Int)\n    # initialize all systems\n    for sys in s.systems\n        initialize!(sys, s.world)\n    end\n\n    # update loop\n    for _ in 1:steps\n        # update all systems\n        for sys in s.systems\n            update!(sys, s.world)\n        end\n    end\n    \n    # finalize all systems\n    for sys in s.systems\n        finalize!(sys, s.world)\n    end\nend","category":"page"},{"location":"manual/systems.html#Initializer-system","page":"Systems","title":"Initializer system","text":"","category":"section"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"Now we can write some systems. First one that creates some entities.","category":"page"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"struct InitializerSystem <: System\n    count::Int\nend\n\nfunction initialize!(s::InitializerSystem, w::World)\n    for (entities, positions, velocities) in @new_entities!(w, s.count, (Position, Velocity))\n        @inbounds for i in eachindex(entities)\n            positions[i] = Position(rand() * 100, rand() * 100)\n            velocities[i] = Velocity(randn(), randn())\n        end\n    end\nend","category":"page"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"As we have the abstract type, we only need to implement the functions that are required for the system.","category":"page"},{"location":"manual/systems.html#Movement-system","page":"Systems","title":"Movement system","text":"","category":"section"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"And here the classical movement system:","category":"page"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"struct MovementSystem <: System\nend\n\nfunction update!(s::InitializerSystem, w::World)\n    for (entities, positions, velocities) in @Query(world, (Position, Velocity))\n        @inbounds for i in eachindex(entities)\n            pos = positions[i]\n            vel = velocities[i]\n            positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n        end\n    end\nend","category":"page"},{"location":"manual/systems.html#Putting-it-together","page":"Systems","title":"Putting it together","text":"","category":"section"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"Finally, we can plug everything together:","category":"page"},{"location":"manual/systems.html","page":"Systems","title":"Systems","text":"world = World(Position, Velocity)\n\nscheduler = Scheduler(\n    world,\n    (\n        InitializerSystem(100),\n        MovementSystem(),\n    ),\n)\n\nrun!(scheduler, 1000)","category":"page"},{"location":"manual/components.html#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"manual/components.html","page":"Components","title":"Components","text":"Components contain the data associated to an Entity, i.e. their properties or state variables.","category":"page"},{"location":"manual/components.html#Component-types","page":"Components","title":"Component types","text":"","category":"section"},{"location":"manual/components.html","page":"Components","title":"Components","text":"Components are distinguished by their type, and each entity can only have one component of a certain type.","category":"page"},{"location":"manual/components.html","page":"Components","title":"Components","text":"In Ark, any type can be used as a component. However, it is highly recommended to use immutable types, because all mutable objects are allocated on the heap in Julia, which defeats Ark's claim of high performance. Immutable types are disallowed by default, but can be enabled when constructing a World by the optional argument allow_mutable of the world constructor.","category":"page"},{"location":"manual/components.html#Accessing-components","page":"Components","title":"Accessing components","text":"","category":"section"},{"location":"manual/components.html","page":"Components","title":"Components","text":"Although the majority of the logic in an application that uses Ark will be performed in Queries, it may be necessary to access components for a particular entity. One or more components of an entity can be accessed via @get_components:","category":"page"},{"location":"manual/components.html","page":"Components","title":"Components","text":"(pos, vel) = @get_components(world, entity, (Position, Velocity))","category":"page"},{"location":"manual/components.html","page":"Components","title":"Components","text":"Similarly, the components of an entity can be overwritten by new values via set_components!, which is particularly useful for immutable components (which are the default):","category":"page"},{"location":"manual/components.html","page":"Components","title":"Components","text":"set_components!(world, entity, (Position(0, 0), Velocity(1,1)))","category":"page"},{"location":"manual/components.html#Adding-and-removing-components","page":"Components","title":"Adding and removing components","text":"","category":"section"},{"location":"manual/components.html","page":"Components","title":"Components","text":"A feature that makes ECS particularly flexible and powerful is the ability to add components to and remove them from entities at runtime. This works similar to component access and can be done via add_components! and @remove_components!:","category":"page"},{"location":"manual/components.html","page":"Components","title":"Components","text":"entity = new_entity!(world, ())\n\nadd_components!(world, entity, (Position(0, 0), Velocity(1,1)))\n@remove_components!(world, entity, (Velocity,))","category":"page"},{"location":"manual/components.html","page":"Components","title":"Components","text":"Note that adding an already existing component of removing a missing one results in an error.","category":"page"},{"location":"manual/components.html","page":"Components","title":"Components","text":"Also note that it is more efficient to add/remove multiple components at once instead of one by one. To allow for efficient exchange of components (i.e. add some and remove others in the same operation), @exchange_components! can be used:","category":"page"},{"location":"manual/components.html","page":"Components","title":"Components","text":"entity = new_entity!(world, (Position(0, 0), Velocity(1,1)))\n\n@exchange_components!(world, entity, \n    add    = (Health(100),),\n    remove = (Position, Velocity),\n)","category":"page"},{"location":"api.html#API","page":"Public API","title":"API","text":"","category":"section"},{"location":"api.html","page":"Public API","title":"Public API","text":"Ark's public API.","category":"page"},{"location":"api.html","page":"Public API","title":"Public API","text":"Pages = [\"api.md\"]\nDepth = 2:2","category":"page"},{"location":"api.html#world-api","page":"Public API","title":"World","text":"","category":"section"},{"location":"api.html","page":"Public API","title":"Public API","text":"The World is the central data storage for Entities, Components and Resources.","category":"page"},{"location":"api.html#Ark.World","page":"Public API","title":"Ark.World","text":"World{CS<:Tuple,CT<:Tuple,N}\n\nThe World is the central ECS storage.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.World-Tuple{Vararg{Type}}","page":"Public API","title":"Ark.World","text":"World(comp_types::Type...; allow_mutable::Bool=false)\n\nCreates a new, empty World for the given component types.\n\nArguments\n\ncomp_types: The component types used by the world.\nallow_mutable: Allows mutable components. Use with care, as all mutable objects are heap-allocated in Julia.\n\nExample\n\nworld = World(Position, Velocity)\n;\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.is_locked","page":"Public API","title":"Ark.is_locked","text":"is_locked(world::World)::Bool\n\nReturns whether the world is currently locked for modifications.\n\n\n\n\n\n","category":"function"},{"location":"api.html#entities-api","page":"Public API","title":"Entities","text":"","category":"section"},{"location":"api.html","page":"Public API","title":"Public API","text":"Entities are the \"game objects\" or \"model entities\". An entity if just an ID with a generation, but Components can be attached to an entity.","category":"page"},{"location":"api.html#Ark.Entity","page":"Public API","title":"Ark.Entity","text":"Entity\n\nEntity identifier.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.zero_entity","page":"Public API","title":"Ark.zero_entity","text":"const zero_entity::Entity\n\nThe reserved zero Entity value.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#Ark.new_entity!","page":"Public API","title":"Ark.new_entity!","text":"new_entity!(world::World, values::Tuple)::Entity\n\nCreates a new Entity with the given component values. Types are inferred from the values.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.new_entities!","page":"Public API","title":"Ark.new_entities!","text":"new_entities!(world::World, n::Int, defaults::Tuple; iterate::Bool=false)::Union{Batch,Nothing}\n\nCreates the given number of Entity, initialized with default values. Component types are inferred from the provided default values.\n\nIf iterate is true, a Batch iterator over the newly created entities is returned that can be used for initialization.\n\nArguments\n\nworld::World: The World instance to use.\nn::Int: The number of entities to create.\ndefaults::Tuple: A tuple of default values for initialization, like (Position(0, 0), Velocity(1, 1)).\niterate::Bool: Whether to return a batch for individual entity initialization.\n\n\n\n\n\nnew_entities!(world::World, n::Int, comp_types::Tuple{Vararg{Val}})::Batch\n\nCreates the given number of Entity.\n\nReturns a Batch iterator over the newly created entities that should be used to initialize components. Note that components are not initialized/undef unless set in the iterator!\n\nFor a more convenient tuple syntax, the macro @new_entities! is provided.\n\nArguments\n\nworld::World: The World instance to use.\nn::Int: The number of entities to create.\ncomp_types::Tuple: Component types for the new entities, like Val.((Position, Velocity)).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.@new_entities!","page":"Public API","title":"Ark.@new_entities!","text":"@new_entities!(world::World, n::Int, comp_types::Tuple{Vararg{Val}})::Batch\n\nCreates the given number of Entity.\n\nReturns a Batch iterator over the newly created entities that should be used to initialize components. Note that components are not initialized/undef unless set in the iterator.\n\nMacro version of new_entities! for ergonomic construction of component mappers.\n\nArguments\n\nworld::World: The World instance to use.\nn::Int: The number of entities to create.\ncomp_types::Tuple: Component types for the new entities, like (Position, Velocity).\n\n\n\n\n\n","category":"macro"},{"location":"api.html#Ark.remove_entity!","page":"Public API","title":"Ark.remove_entity!","text":"remove_entity!(world::World, entity::Entity)\n\nRemoves an Entity from the World.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.is_alive","page":"Public API","title":"Ark.is_alive","text":"is_alive(world::World, entity::Entity)::Bool\n\nReturns whether an Entity is alive.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.is_zero","page":"Public API","title":"Ark.is_zero","text":"is_zero(entity::Entity)::Bool\n\nReturns whether an Entity is the zero entity.\n\n\n\n\n\n","category":"function"},{"location":"api.html#components-api","page":"Public API","title":"Components","text":"","category":"section"},{"location":"api.html","page":"Public API","title":"Public API","text":"Components contain the data associated with Entities","category":"page"},{"location":"api.html#Ark.get_components","page":"Public API","title":"Ark.get_components","text":"get_components(world::World, entity::Entity, comp_types::Tuple)\n\nGet the given components for an Entity. Components are returned in a tuple.\n\nFor a more convenient tuple syntax, the macro @get_components is provided.\n\nExample\n\npos, vel = get_components(world, entity, Val.((Position, Velocity)))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.@get_components","page":"Public API","title":"Ark.@get_components","text":"@get_components(world::World, entity::Entity, comp_types::Tuple)\n\nGet the given components for an Entity. Components are returned in a tuple.\n\nMacro version of get_components for more ergonomic component type tuples.\n\nExample\n\npos, vel = @get_components(world, entity, (Position, Velocity))\n\n\n\n\n\n","category":"macro"},{"location":"api.html#Ark.has_components","page":"Public API","title":"Ark.has_components","text":"has_components(world::World, entity::Entity, comp_types::Tuple)::Bool\n\nReturns whether an Entity has all given components.\n\nFor a more convenient tuple syntax, the macro @has_components is provided.\n\nExample\n\nhas = has_components(world, entity, Val.((Position, Velocity)))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.@has_components","page":"Public API","title":"Ark.@has_components","text":"@has_components(world::World, entity::Entity, comp_types::Tuple)::Bool\n\nReturns whether an Entity has all given components.\n\nMacro version of has_components for more ergonomic component type tuples.\n\nExample\n\nhas = @has_components(world, entity, (Position, Velocity))\n\n\n\n\n\n","category":"macro"},{"location":"api.html#Ark.set_components!","page":"Public API","title":"Ark.set_components!","text":"set_components!(world::World, entity::Entity, values::Tuple)\n\nSets the given component values for an Entity. Types are inferred from the values. The entity must already have all these components.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.add_components!","page":"Public API","title":"Ark.add_components!","text":"add_components!(world::World, entity::Entity, values::Tuple)\n\nAdds the given component values to an Entity. Types are inferred from the values.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.remove_components!","page":"Public API","title":"Ark.remove_components!","text":"remove_components!(world::World, entity::Entity, comp_types::Tuple)\n\nRemoves the given components from an Entity.\n\nFor a more convenient tuple syntax, the macro @remove_components! is provided.\n\nExample\n\nremove_components!(world, entity, Val.((Position, Velocity)))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.@remove_components!","page":"Public API","title":"Ark.@remove_components!","text":"@remove_components!(world::World, entity::Entity, comp_types::Tuple)\n\nRemoves the given components from an Entity.\n\nMacro version of remove_components! for ergonomic construction of component mappers.\n\nExample\n\n@remove_components!(world, entity, (Position, Velocity))\n\n\n\n\n\n","category":"macro"},{"location":"api.html#Ark.exchange_components!","page":"Public API","title":"Ark.exchange_components!","text":"exchange_components!(world::World{CS,CT,N}, entity::Entity; add::Tuple, remove::Tuple)\n\nAdds and removes components on an Entity. Types are inferred from the add values.\n\nFor a more convenient tuple syntax, the macro @exchange_components! is provided.\n\nExample\n\nexchange_components!(world, entity;\n    add=(Health(100),),\n    remove=Val.((Position, Velocity)),\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.@exchange_components!","page":"Public API","title":"Ark.@exchange_components!","text":"@exchange_components!(world::World, entity::Entity, add::Tuple, remove::Tuple)\n\nRemoves the given components from an Entity.\n\nMacro version of exchange_components! for more ergonomic component type tuples.\n\nExample\n\n@exchange_components!(world, entity,\n    add = (Health(100),),\n    remove = Val.((Position, Velocity)),\n)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#queries-api","page":"Public API","title":"Queries","text":"","category":"section"},{"location":"api.html","page":"Public API","title":"Public API","text":"Queries are used to filter and process Entities with a certain set of Components.","category":"page"},{"location":"api.html#Ark.Query","page":"Public API","title":"Ark.Query","text":"Query\n\nA query for components.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.@Query","page":"Public API","title":"Ark.@Query","text":"@Query(\n    world::World,\n    comp_types::Tuple,\n    with::Tuple=(),\n    without::Tuple=(),\n    optional::Tuple=(),\n    exclusive::Bool=false\n)\n\nCreates a query.\n\nMacro version of Query that allows ergonomic construction of queries using simulated keyword arguments.\n\nQueries can be stored and re-used. However, query creation is fast (<20ns), so this is not mandatory.\n\nArguments\n\nworld: The World instance to query.\ncomp_types::Tuple: Components the query filters for and provides access to. Must be a literal tuple like (Position, Velocity).\nwith::Tuple: Additional components the entities must have. Passed as with=(Health,).\nwithout::Tuple: Components the entities must not have. Passed as without=(Altitude,).\noptional::Tuple: Components that are optional in the query. Passed as optional=(Velocity,).\nexclusive::Bool: Makes the query exclusive in base and with components, can't be combined with without.\n\nExample\n\nfor (entities, positions, velocities) in @Query(world, (Position, Velocity))\n    for i in eachindex(entities)\n        pos = positions[i]\n        vel = velocities[i]\n        positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"api.html#Ark.close!-Tuple{Query}","page":"Public API","title":"Ark.close!","text":"close!(q::Query)\n\nCloses the query and unlocks the world.\n\nMust be called if a query is not fully iterated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.Entities","page":"Public API","title":"Ark.Entities","text":"Entities\n\nArchetype column for entities. Can be iterated and indexed like a Vector.\n\nUsed in query iteration.\n\n\n\n\n\n","category":"type"},{"location":"api.html#resources-api","page":"Public API","title":"Resources","text":"","category":"section"},{"location":"api.html","page":"Public API","title":"Public API","text":"Resources are singleton-like data structures that appear only once in a World and are not associated to an Entity.","category":"page"},{"location":"api.html#Ark.get_resource","page":"Public API","title":"Ark.get_resource","text":"get_resource(world::World, res_type::Type{T})::T\n\nGet the resource of type T from the world.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.has_resource","page":"Public API","title":"Ark.has_resource","text":"has_resource(world::World, res_type::Type{T})::Bool\n\nCheck if a resource of type T is in the world.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.add_resource!","page":"Public API","title":"Ark.add_resource!","text":"add_resource!(world::World, res::T)::T\n\nAdd the given resource to the world. Returns the newly added resource.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.set_resource!","page":"Public API","title":"Ark.set_resource!","text":"set_resource!(world::World, res::T)::T\n\nOverwrites an existing resource in the world. Returns the newly overwritten resource.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.remove_resource!","page":"Public API","title":"Ark.remove_resource!","text":"remove_resource!(world::World, res_type::Type{T})::T\n\nRemove the resource of type T from the world. Returns the removed resource.\n\n\n\n\n\n","category":"function"},{"location":"api.html#batch-api","page":"Public API","title":"Batch","text":"","category":"section"},{"location":"api.html","page":"Public API","title":"Public API","text":"An iterator over entities that were created or modified using batch operations. Behaves like a Query and can be used for component initialization.","category":"page"},{"location":"api.html#Ark.Batch","page":"Public API","title":"Ark.Batch","text":"Batch\n\nA batch iterator. This is returned from batch operations and serves for initializing newly added components.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.close!-Tuple{Batch}","page":"Public API","title":"Ark.close!","text":"close!(b::Batch)\n\nCloses the batch iterator and unlocks the world.\n\nMust be called if a batch is not fully iterated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"Public API","title":"Public API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"manual/queries.html#Queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"Queries allow to select Entities that have a certain set of Components and to manipulate them.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"Queries are the heart of every ECS and the main reason for its flexibility and performance. In Ark, queries are blazing fast and should be used to write the game or model logic where possible. For cases where components of a particular entity are required, see section Accessing components.","category":"page"},{"location":"manual/queries.html#Basic-queries","page":"Queries","title":"Basic queries","text":"","category":"section"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"By default, a Query lets you iterate over all entities that have the query's components, and provides efficient access to these components.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"Here, we are interested only in non-exclusive sets. So the entities that are processed may have further components, but they are not of interest for that particular piece of game or model logic.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"for (entities, positions, velocities) in @Query(world, (Position, Velocity))\n    @inbounds for i in eachindex(entities)\n        pos = positions[i]\n        vel = velocities[i]\n        positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n    end\nend","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"Note the nested loop! In the outer loop, the query iterates the archetypes, and for each one returns a vector of entities and the columns for the queried components. In the inner loop, we iterate over the entities within the archetype and perform the actual logic.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"Also not the last line in the inner loop. Here, we assign a new Position value to the current entity. This is necessary as Position is immutable, which is the default and highly recommended. See section Component types for details.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"The @inbounds macro in front of the inner loop is optional, but it is safe to use here and makes the iteration faster as it allows the compiler to skip bounds checks.","category":"page"},{"location":"manual/queries.html#Advanced-queries","page":"Queries","title":"Advanced queries","text":"","category":"section"},{"location":"manual/queries.html#with","page":"Queries","title":"with","text":"","category":"section"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"Queries provide an optional with argument that filters for additional components that entities must have, but that are not used by the query.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"for (entities, positions, velocities) in @Query(world,\n            (Position, Velocity),\n            with=(Health,)\n        )\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"page"},{"location":"manual/queries.html#without","page":"Queries","title":"without","text":"","category":"section"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"The optional without argument allows to exclude entities that have certain components:","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"for (entities, positions, velocities) in @Query(world,\n            (Position, Velocity),\n            without=(Health,)\n        )\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"page"},{"location":"manual/queries.html#exclusive","page":"Queries","title":"exclusive","text":"","category":"section"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"The optional exclusive argument excludes entities that have any other then the query's components and those specified by with. So it acts like an exhaustive without:","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"for (entities, positions, velocities) in @Query(world,\n            (Position, Velocity),\n            exclusive=true\n        )\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"page"},{"location":"manual/queries.html#optional","page":"Queries","title":"optional","text":"","category":"section"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"The optional optional argument makes components optional. 😉","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"Entities are included irrespective of presence of these components on them. Note that, in contrast to the other arguments, this one is not related to additional components, but refers to components of the query's \"normal\" components set.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"Optional components are still included in the iterator's columns tuple, but they are nothing if the current archetype does not have them.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"for (entities, positions, velocities) in @Query(world,\n            (Position, Velocity),\n            optional=(Velocity,)\n        )\n    has_velocity = velocities !== nothing\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"Note that it is possible to branch already outside of the inner loop, as all entities in an archetype either have a component or don't.","category":"page"},{"location":"manual/queries.html#World-lock","page":"Queries","title":"World lock","text":"","category":"section"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"During query iteration, the World is locked for modifications like entity creation and removal and component addition and removal. This is necessary to prevent changes to the inner storage structure of the World that would result in undefined behavior of the query.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"If the necessity for these forbidden iteration arises, the respective entities must be collected into a Vector to apply the operations after query iteration has finished.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"# vector for entities to be removed from te world\nto_remove = Entity[]\n\nfor (entities, positions) in @Query(world, (Position,))\n    @inbounds for i in eachindex(entities)\n        pos = positions[i]\n\n        # collect entities for removal\n        if pos.y < 0\n            push!(to_remove, entities[i])\n        end\n    end\nend\n\n# actual removal\nfor entity in to_remove\n    remove_entity!(world, entity)\nend\n\n# clear the vector for re-use\nresize!(to_remove, 0)","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"For the best performance, such a Vector should be stored persistently and re-used to avoid repeated memory allocations.","category":"page"},{"location":"manual/queries.html","page":"Queries","title":"Queries","text":"The world is automatically unlocked when query iteration finishes. When breaking out of a query loop, however, it must be unlocked by calling close! on the query.","category":"page"},{"location":"manual/world.html#The-World","page":"The World","title":"The World","text":"","category":"section"},{"location":"manual/world.html","page":"The World","title":"The World","text":"A World is the central data store for any application that uses Ark.jl. It managed Entities, Components and Resources, and all these are always tied to a World.","category":"page"},{"location":"manual/world.html","page":"The World","title":"The World","text":"Most applications will have exactly one world, but multiple worlds can exist at the same time.","category":"page"},{"location":"manual/world.html#World-creation","page":"The World","title":"World creation","text":"","category":"section"},{"location":"manual/world.html","page":"The World","title":"The World","text":"When creating a new world, all Component types that can exist in it must be specified.","category":"page"},{"location":"manual/world.html","page":"The World","title":"The World","text":"using Ark\n\nstruct Position\n    x::Float64\n    y::Float64\nend\n\nstruct Velocity\n    dx::Float64\n    dy::Float64\nend\n\nworld = World(Position, Velocity)\n; # Suppress print output","category":"page"},{"location":"manual/world.html","page":"The World","title":"The World","text":"This may seem usual, but it allows Ark to leverage Julia's compile-time programming features for the best performance.","category":"page"},{"location":"manual/world.html#World-functionality","page":"The World","title":"World functionality","text":"","category":"section"},{"location":"manual/world.html","page":"The World","title":"The World","text":"You will see that almost all methods in Ark's API take a World as their first argument. These methods are explained in the following chapters.","category":"page"},{"location":"manual/architecture.html#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"manual/architecture.html","page":"Architecture","title":"Architecture","text":"This chapter describes the principles of Ark's architecture, which may be useful to understand what is actually going on, and to understand performance trade-offs.","category":"page"},{"location":"manual/architecture.html","page":"Architecture","title":"Architecture","text":"For now, see chapter Architecture of the Go ECS Ark, which Arks.jl is a port of.","category":"page"},{"location":"manual/architecture.html","page":"Architecture","title":"Architecture","text":"TODO","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<div style=\"text-align: center;\">\n\n<img src=\"assets/ark-logo-text-light.svg\" class=\"only-light\" alt=\"Ark.jl (logo)\" />\n<img src=\"assets/ark-logo-text-dark.svg\" class=\"only-dark\" alt=\"Ark.jl (logo)\" />","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage) (Image: Docs stable) (Image: Docs dev) (Image: GitHub) (Image: MIT license) (Image: Apache 2.0 license) (Image: Aqua QA)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Ark.jl is an archetype-based Entity Component System (ECS) for Julia. It is a port of the Go ECS Ark.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"&mdash;&mdash;\n</div>","category":"page"},{"location":"index.html#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Designed for performance and highly optimized.\nWell-documented, type-safe API.\nBlazing fast batch entity creation.\nNo systems. Just queries. Use your own structure.\nMinimal dependencies, 100% test coverage.","category":"page"},{"location":"index.html#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Quickstart\nThe World\nEntities\nComponents\nQueries\nSystems\nResources\nArchitecture","category":"page"},{"location":"index.html#API-Outline","page":"Home","title":"API Outline","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"api.md\"]\nDepth = 2:2","category":"page"},{"location":"index.html#API-Index","page":"Home","title":"API Index","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"api.md\"]","category":"page"}]
}
