var documenterSearchIndex = {"docs":
[{"location":"manual/entities.html#Entities","page":"Entities","title":"Entities","text":"Entities are the \"game objects\" or \"model entities\" in applications that use Ark. In effect, an entity is just an ID that can be associated with Components, which contain the entity's properties or state variables.","category":"section"},{"location":"manual/entities.html#creating-entities","page":"Entities","title":"Creating entities","text":"An entity can only exist in a World, and thus can only be created through a World.\n\nHere, we use new_entity! to create an entity with a Position and a Velocity components. Note that component values are passed as a tuple!\n\nentity = new_entity!(world, (\n    Position(100, 100),\n    Velocity(0, 0),\n))\n\nComponents can be added to and removed from the entity later. This is described in the next chapter.\n\nOften, multiple entities with the same set of components are created at the same time. For that sake, Ark provides batch entity creation, which is much faster than creating entities one by one. See chapter Batch operations for details.","category":"section"},{"location":"manual/entities.html#Removing-entities","page":"Entities","title":"Removing entities","text":"Removing an entity from the World is as simple as this, using remove_entity!:\n\nremove_entity!(world, entity)\n\nFor removing many entities in batches, see chapter Batch operations.","category":"section"},{"location":"manual/entities.html#Alive-status","page":"Entities","title":"Alive status","text":"Entities can be safely stored, e.g. in the Components of other entities to represent relationships. However, as they may have been removed from the world elsewhere, it may be necessary to check whether an entity is still alive with is_alive:\n\nif is_alive(world, entity)\n    # ...\nend","category":"section"},{"location":"manual/entities.html#Zero-entity","page":"Entities","title":"Zero entity","text":"There is a reserved zero_entity that can be used as a placeholder for \"no entity\". The zero entity is never alive. The function is_zero can be used to determine whether an entity is the zero entity:\n\nif is_zero(entity)\n    # ...\nend","category":"section"},{"location":"manual/batch.html#Batch-operations","page":"Batch operations","title":"Batch operations","text":"In an archetype-based ECS, creation and removal of entities or components are relatively costly operations. For these operations, Ark provides batched versions. This allows to create or manipulate a large number of entities much faster than one by one. All batch methods come in two flavors. A \"normal\" one, and one that runs a callback function on the affected entities.","category":"section"},{"location":"manual/batch.html#Creating-entities","page":"Batch operations","title":"Creating entities","text":"Often, multiple entities with the same set of components are created at the same time. Batch entity creation is therefore probably the most frequently used batch operation. There are different ways to create entities in batches:\n\nFrom default component values using new_entities!. Here, we create 100 entities, all with the same Position and Velocity:\n\nnew_entities!(world, 100, (\n    Position(100, 100),\n    Velocity(0, 0),\n))\n\nThis may be sufficient in some use cases, but most often we will use a second approach:\n\nFrom component types with subsequent manual initialization using new_entities! with a tuple of types:\n\nnew_entities!(world, 100, (Position, Velocity)) do (entities, positions, velocities)\n    for i in eachindex(entities)\n        positions[i] = Position(i, i)\n        velocities[i] = Velocity(0, 0)\n    end\nend\n\nNote that the tuple elements of the callback argument are entity and component columns that need to be iterated to access individual items. See also the chapter on Queries, which use a similar nested loop structure.\n\nNote that with the second approach, all components of all entities should be set as they are otherwise uninitialized. Therefore, the callback is mandatory here, while it is optional for batch creation from default values.","category":"section"},{"location":"manual/batch.html#Removing-entities","page":"Batch operations","title":"Removing entities","text":"Similar to entity creation, entities can also be removed in batches with remove_entities!. It takes a Filter instead of a single entity as argument:\n\nfilter = Filter(world, (Position, Velocity))\nremove_entities!(world, filter)\n\nIf something needs to be done with the entities to be removed, a callback can be used, which takes an Entities column as an argument:\n\nfilter = Filter(world, (Position, Velocity))\nremove_entities!(world, filter) do entities\n    # do something with the entities...\nend","category":"section"},{"location":"manual/batch.html#Adding-and-removing-components","page":"Batch operations","title":"Adding and removing components","text":"The functions add_components!, remove_components! and exchange_components! also come with batch versions.\n\nSimilarly to batch entity creation, components to be added can be given either in the form of default values, or as types. In the case of default values, usage of the callback is optional, while it is mandatory for initialization with the types version.\n\nHere, we add a default Velocity component to all entities with Position, using add_components!:\n\nfilter = Filter(world, (Position,))\nadd_components!(world, filter, (Velocity(0, 0),))\n\nAdding components via types, with individual initialization:\n\nfilter = Filter(world, (Position,))\nadd_components!(world, filter, (Velocity,)) do (entities, velocities)\n    for i in eachindex(entities, velocities)\n        velocities[i] = Velocity(randn(), randn())\n    end\nend\n\nNote that the tuple elements of the callback argument are entity and component columns that need to be iterated to access individual items. See also the chapter on Queries, which use a similar nested loop structure.\n\nRemoving components works in a similar way, with remove_components!:\n\nfilter = Filter(world, (Velocity,))\nremove_components!(world, filter, (Velocity,))\n\nNote that the optional callback has only an Entities column as argument:\n\nfilter = Filter(world, (Velocity,))\nremove_components!(world, filter, (Velocity,)) do entities\n    # do something with the entities...\nend\n\nFinally, exchanging components with exchange_components! follows the same pattern as adding components:\n\nfilter = Filter(world, (Velocity,))\nexchange_components!(world, filter;\n    add=(Health(100),),\n    remove=(Velocity,),\n)\n\nNote that, again, when adding components as types, the callback is mandatory. Also note that only the added components are part of the callback's argument tuple, while the removed components are not.\n\nfilter = Filter(world, (Velocity,))\nexchange_components!(world, filter;\n    add=(Health,),\n    remove=(Velocity,),\n) do (entities, healths)\n    for i in eachindex(entities, healths)\n        healths[i] = Health(i * 2)\n    end\nend","category":"section"},{"location":"manual/batch.html#Setting-relationships","page":"Batch operations","title":"Setting relationships","text":"As with other operations, relation targets can be set in batches using set_relations! combined with a Filter:\n\nfilter = Filter(world, (ChildOf,); relations=(ChildOf => parent,))\nset_relations!(world, filter, (ChildOf => parent2,))\n\nIf necessary, the affected entities can be processed using a callback function:\n\nfilter = Filter(world, (ChildOf,); relations=(ChildOf => parent,))\nset_relations!(world, filter, (ChildOf => parent2,)) do entities\n    # do something with the entities...\nend","category":"section"},{"location":"manual/resources.html#Resources","page":"Resources","title":"Resources","text":"Resources are singular data structures in an ECS World. As such, they can be thought of as Components that exist only once and are not associated to an Entity. Examples could be the current game/simulation tick, a grid that your entities live on, or an acceleration structure for spatial indexing.","category":"section"},{"location":"manual/resources.html#Creating-resources","page":"Resources","title":"Creating resources","text":"Resources can be of any type, but only one resource of a particular type can exist in a World. They are simply added to the world with add_resource!:\n\nstruct Tick\n    time::Int\nend\n\nadd_resource!(world, Tick(0))","category":"section"},{"location":"manual/resources.html#Accessing-resources","page":"Resources","title":"Accessing resources","text":"Resources can be retrieved via get_resource:\n\ntick = get_resource(world, Tick)\ntime = tick.time\n\nAs getting a resource is not particularly fast (≈10ns), this should not be done in hot loops like queries, but beforehand.\n\nThe existence of a resource type in the World can be checked with has_resource:\n\nif has_resource(world, Tick)\n    # ...\nend","category":"section"},{"location":"manual/resources.html#Setting-and-removing-resources","page":"Resources","title":"Setting and removing resources","text":"Resources can also be removed from the world using remove_resource!, or overwritten with set_resource!, which is particularly useful for immutable types:\n\nset_resource!(world, Tick(1))\nremove_resource!(world, Tick)","category":"section"},{"location":"demos.html#Demos","page":"Demos","title":"Demos","text":"The Ark repository contains a number of runnable demos. These are listed here, alongside instructions for running them.","category":"section"},{"location":"demos.html#Running-a-demo","page":"Demos","title":"Running a demo","text":"<details>\n<summary><b>Click for instructions</b></summary>\n<br/>\n<p>\nFirst, clone the repository and `cd` into it:\n</p>\n\n<pre><code class=\"language-shell hljs\">git clone https://github.com/ark-ecs/Ark.jl.git\ncd Ark.jl\n</code></pre>\n\n<p>\nNext, instantiate the demos project:\n</p>\n\n<pre><code class=\"language-shell hljs\">julia --project=demos -e 'using Pkg; Pkg.develop(path=\".\"); Pkg.instantiate()'\n</code></pre>\n\n<p>\nRun individual demos like this:\n</p>\n\n<pre><code class=\"language-shell hljs\">julia --project=demos demos/&lt;DEMO&gt;/main.jl\n</code></pre>\n\n<p>\nMost of the demos are interactive, so try hovering the mouse over the window.\n</p>\n\n</details>","category":"section"},{"location":"demos.html#Logo","page":"Demos","title":"Logo","text":"An animated, interactive Ark.jl logo. Use only the most basic features of Ark. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"Logo demo\" src=\"https://raw.githubusercontent.com/ark-ecs/Ark.jl/refs/heads/gh-images/screenshots/logo.png\" />\n</div>","category":"section"},{"location":"demos.html#SIR","page":"Demos","title":"SIR","text":"A simple individual-based epidemiologic SIR model. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"SIR demo\" src=\"https://raw.githubusercontent.com/ark-ecs/Ark.jl/refs/heads/gh-images/screenshots/sir.png\" />\n</div>","category":"section"},{"location":"demos.html#Boids","page":"Demos","title":"Boids","text":"Boids model, resembling bird flocks or fish schools. Makes use of entities stored in a spatial acceleration structure, as well as in components. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"SIR demo\" src=\"https://raw.githubusercontent.com/ark-ecs/Ark.jl/refs/heads/gh-images/screenshots/boids.png\" />\n</div>","category":"section"},{"location":"demos.html#Network","page":"Demos","title":"Network","text":"Random travelers on a network. Makes massive use of entities stored in components. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"SIR demo\" src=\"https://raw.githubusercontent.com/ark-ecs/Ark.jl/refs/heads/gh-images/screenshots/network.png\" />\n</div>","category":"section"},{"location":"demos.html#Grazers","page":"Demos","title":"Grazers","text":"An model for the evolution of the foraging behavior of grazers. Dynamically adds and removes components to handle behavioral states. Source code.\n\n<div style=\"text-align: center;\">\n<img alt=\"SIR demo\" src=\"https://raw.githubusercontent.com/ark-ecs/Ark.jl/refs/heads/gh-images/screenshots/grazers.png\" />\n</div>","category":"section"},{"location":"manual/events.html#Event-system","page":"Event system","title":"Event system","text":"Ark provides an event system with observers that allow an application to react on events, such as adding and removing components and entities.\n\nObservers can filter for the events they are interested in, in several ways. A callback function is executed for the affected entity whenever an observer's filter matches.\n\nIn addition to built-in lifecycle events like OnCreateEntity or OnAddComponents, Ark supports custom event types that enable domain-specific triggers. These events can be emitted manually and observed with the same filtering and callback mechanisms, making them ideal for modeling interactions such as user input, synchronization, or game logic.\n\nObservers are lightweight, composable, and follow the same declarative patterns as Ark’s query system. They provide fine-grained control over when and how logic is executed. This design encourages a declarative, data-driven approach while maintaining performance and flexibility.","category":"section"},{"location":"manual/events.html#Example","page":"Event system","title":"Example","text":"Use observe! to observe for events:\n\nobserve!(world, OnAddComponents, (Position, Velocity)) do entity\n    pos, vel = get_components(world, entity, (Position, Velocity))\n    println(pos)\n    println(vel)\nend\n\nentity = new_entity!(world, ())\nadd_components!(world, entity, (Position(0, 0), Velocity(1, 1)))","category":"section"},{"location":"manual/events.html#Event-types","page":"Event system","title":"Event types","text":"Observers are specific for different event types, and each observer can react only to one type. See below for how to react on multiple different types.\n\nOnCreateEntity: Emitted after a new entity is created.  \nOnRemoveEntity: Emitted before an entity is removed.\nOnAddComponents: Emitted after components are added to an existing entity.\nOnRemoveComponents: Emitted before components are removed from an entity.\nOnAddRelations: Emitted after relation targets are added to an existing entity.*\nOnRemoveRelations: Emitted before relation targets are removed from an entity.*\n\nIf multiple components are added/removed for an entity, one event is emitted for the entire operation.\n\n* Relation events are emitted when entities with relations are created or removed, when relation components are added or removed, as well as when targets are set without changing components.","category":"section"},{"location":"manual/events.html#combining-types","page":"Event system","title":"Combining multiple types","text":"Observers can be combined to react to multiple event types in a single callback function. Below is a combination of observers to react on component addition as well as removal. The callback is set up to be able to distinguish between these event types (if needed).\n\nfn = (event::EventType, entity::Entity) -> begin\n    if event == OnAddComponents\n        println(\"Position added\")\n    elseif event == OnRemoveComponents\n        println(\"Position removed\")\n    end\nend\n\nobserve!(world, OnAddComponents, (Position,)) do entity\n    fn(OnAddComponents, entity)\nend\nobserve!(world, OnRemoveComponents, (Position,)) do entity\n    fn(OnRemoveComponents, entity)\nend","category":"section"},{"location":"manual/events.html#Filters","page":"Event system","title":"Filters","text":"Observers only trigger when all specified components (last non-keyword argument) are affected in a single operation. For example, if an observer watches Position and Velocity, both must be added or removed together for the observer to activate.\n\nFurther, events can be filtered by the composition of the affected entity via the keyword arguments with, without and exclusive, just like queries.\n\nFor entity creation and removal, only the keyword arguments can be used.\n\nExamples (leaving out observer registration):\n\nAn observer that is triggered when a Position component is added to an existing entity:\n\nobserve!(world, OnAddComponents, (Position,)) do entity\n    # ...\nend\n\nAn observer that is triggered when a Position component is added to an entity that has Velocity, but not Altitude (or rather, had before the operation):\n\nobserve!(world, OnAddComponents, (Position,);\n        with    = (Velocity,),\n        without = (Altitude,)\n    ) do entity\n    # ...\nend\n\nThis observer is triggered when an entity with Position is created:\n\nobserve!(world, OnCreateEntity;\n        with = (Velocity,)\n    ) do entity\n    # ...\nend\n\nThis observer is triggered when an entity with Position as well as Velocity is created:\n\nobserve!(world, OnCreateEntity;\n        with = (Position, Velocity)\n    ) do entity\n    # ...\nend\n\nAn observer that is triggered when any entity is created, irrespective of its components:\n\nobserve!(world, OnCreateEntity) do entity\n    # ...\nend","category":"section"},{"location":"manual/events.html#Event-timing","page":"Event system","title":"Event timing","text":"The time an event is emitted relative to the operation it is related to depends on the event's type. The observer callbacks are executed immediately by any emitted event.\n\nEvents for entity creation and for adding or setting components are emitted after the operation. Hence, the new or changed components can be inspected in the observer's callback. If emitted from individual operations, the world is in an unlocked state when the callback is executed. Contrary, when emitted from a batch operation, the world is locked.\n\nEvents for entity or component removal are emitted before the operation. This way, the entity or component to be removed can be inspected in the observer's callback. In this case, the world is locked when the callback is executed.\n\nNote that observer order is undefined. Observers are not necessarily triggered in the same order as they were registered.","category":"section"},{"location":"manual/events.html#custom-events","page":"Event system","title":"Custom events","text":"Custom events in Ark allow developers to define and emit their own event types, enabling application-specific logic such as UI interactions, game state changes, or other domain-specific triggers. These events support the same filtering and observer mechanisms as built-in events.\n\nDefine custom event types using an EventRegistry and neweventtype!:\n\n# Create an event registry\nregistry = EventRegistry()\n\n# Create event types\nconst OnCollisionDetected = new_event_type!(registry, :OnCollisionDetected)\nconst OnInputReceived     = new_event_type!(registry, :OnInputReceived)\nconst OnLevelLoaded       = new_event_type!(registry, :OnLevelLoaded)\nconst OnTimerElapsed      = new_event_type!(registry, :OnTimerElapsed)\n\nIdeally, custom event types are stored as global variables of the applications.\n\nUse emit_event! to emit custom events:\n\nregistry = EventRegistry()\nconst OnTeleport = new_event_type!(registry, :OnTeleport)\n\n# Add an observer for the event type\nobserve!(world, OnTeleport, (Position,)) do entity\n    # ...\nend\n\n# Emit the event for an entity and component type(s)\nemit_event!(world, OnTeleport, entity, (Position,))\n\nObservers might not be interested in components, or in more than one component. This is also supported by custom events:\n\nregistry = EventRegistry()\nconst OnClick = new_event_type!(registry, :OnClick)\n\nemit_event!(world, OnClick, ui_element)\n\nNote that custom events can also be emitted for the zero entity:\n\nregistry = EventRegistry()\nconst OnGameOver = new_event_type!(registry, :OnGameOver)\n\nemit_event!(world, OnGameOver, zero_entity)\n\nFor custom events, observer filters work exactly the same as for predefined events. The components in the last (optional) non-keyword argument are matched against the components of the event. with, without and exclusive are matched against the entity for which the event is emitted.","category":"section"},{"location":"manual/quickstart.html#Quickstart","page":"Quickstart","title":"Quickstart","text":"This page shows how to install Ark.jl, and gives a minimal usage example.\n\nFinally, it points into possible directions to continue.","category":"section"},{"location":"manual/quickstart.html#Installation","page":"Quickstart","title":"Installation","text":"Run this to add Ark.jl to a Julia project:\n\nusing Pkg\nPkg.add(\"Ark\")","category":"section"},{"location":"manual/quickstart.html#Example","page":"Quickstart","title":"Example","text":"Here is the classical Position/Velocity example that every ECS shows in the docs.\n\nRead the next chapters and view the API docs and demos for more details.\n\nusing Ark\n\n\"\"\"Position component\"\"\"\nstruct Position\n    x::Float64\n    y::Float64\nend\n\n\"\"\"Velocity component\"\"\"\nstruct Velocity\n    dx::Float64\n    dy::Float64\nend\n\n# Create a world with the required components\nworld = World(Position, Velocity)\n\nfor i in 1:1000\n    # Create an entity with components\n    entity = new_entity!(world, (Position(i, i * 2), Velocity(1, 1)))\nend\n\n# Time loop\nfor i in 1:10\n    # Iterate a query (archetypes)\n    for (entities, positions, velocities) in Query(world, (Position, Velocity))\n        # Iterate entities in the current archetype\n        @inbounds for i in eachindex(entities)\n            # Get components of the current entity\n            pos = positions[i]\n            vel = velocities[i]\n            # Update an (immutable) component\n            positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n        end\n    end\nend","category":"section"},{"location":"manual/quickstart.html#What's-next?","page":"Quickstart","title":"What's next?","text":"If you ask \"What is ECS?\", take a look at the great ECS FAQ by Sander Mertens, the author of the Flecs ECS.\n\nTo learn how to use Ark.jl, read the following chapters, browse the API documentation, or take a look at the GitHub repository.","category":"section"},{"location":"benchmarks.html#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"Several performance benchmarks for Ark.jl.\n\nMore to come soon...","category":"section"},{"location":"benchmarks.html#Ark-vs.-AoS","page":"Benchmarks","title":"Ark vs. AoS","text":"The figure below shows the classical Position/Velocity (movement system) benchmark, comparing Ark with the Array of Structs approach. Note that the data is from runs on the powerful GitHub CI machines. These have way more cache then consumer machines, where the performance advantage of Ark would be even more emphasized.\n\n<img src=\"assets/images/bench_aos_light.svg\" class=\"only-light\" alt=\"Benchmark vs. AoS\" />\n<img src=\"assets/images/bench_aos_dark.svg\" class=\"only-dark\" alt=\"Benchmark vs. AoS\" />\n\nArk vs. AoS: Legend entries denote the size of entities in bytes and in the number of Float64 fields.","category":"section"},{"location":"manual/systems.html#Systems","page":"Systems","title":"Systems","text":"Ark provides no systems as they are widely known in ECS implementations. This is a deliberate decision, based on these reasons:\n\nSystems can be hard to integrate into frameworks, like a game engine's update loop.   Ark wants to stay flexible and is completely engine-agnostic.\nSystems are usually tied to queries in a 1:1 relation, while it can be very useful to combine multiple queries.\nSystems and a scheduler are easy to implement, so this is left to the user.\n\nBelow, we provide an example for how to implement systems and a scheduler.","category":"section"},{"location":"manual/systems.html#Systems-example","page":"Systems","title":"Systems example","text":"","category":"section"},{"location":"manual/systems.html#sys-components","page":"Systems","title":"Components","text":"We start by defining our component types:\n\nusing Ark\n\nstruct Position\n    x::Float64\n    y::Float64\nend\nstruct Velocity\n    dx::Float64\n    dy::Float64\nend","category":"section"},{"location":"manual/systems.html#Abstract-system-type","page":"Systems","title":"Abstract system type","text":"We write an abstract system type. This is optional, but useful for clarity and to avoid boilerplate.\n\nabstract type System end\n\nfunction initialize!(::System, ::World) end\nfunction update!(::System, ::World) end\nfunction finalize!(::System, ::World) end","category":"section"},{"location":"manual/systems.html#Scheduler","page":"Systems","title":"Scheduler","text":"Next, we build a (type-stable) scheduler:\n\nstruct Scheduler{ST<:Tuple}\n    world::World\n    systems::ST\nend\n\nfunction run!(s::Scheduler, steps::Int)\n    # initialize all systems\n    for sys in s.systems\n        initialize!(sys, s.world)\n    end\n\n    # update loop\n    for _ in 1:steps\n        # update all systems\n        for sys in s.systems\n            update!(sys, s.world)\n        end\n    end\n    \n    # finalize all systems\n    for sys in s.systems\n        finalize!(sys, s.world)\n    end\nend","category":"section"},{"location":"manual/systems.html#Initializer-system","page":"Systems","title":"Initializer system","text":"Now we can write some systems. First one that creates some entities:\n\nstruct InitializerSystem <: System\n    count::Int\nend\n\nfunction initialize!(s::InitializerSystem, w::World)\n    new_entities!(w, s.count, (Position, Velocity)) do (entities, positions, velocities)\n        @inbounds for i in eachindex(entities)\n            positions[i] = Position(rand() * 100, rand() * 100)\n            velocities[i] = Velocity(randn(), randn())\n        end\n    end\nend\n\nAs we have the abstract type, we only need to implement the functions that are actually required for the system.","category":"section"},{"location":"manual/systems.html#Movement-system","page":"Systems","title":"Movement system","text":"And here the classical movement system:\n\nstruct MovementSystem <: System end\n\nfunction update!(s::InitializerSystem, w::World)\n    for (entities, positions, velocities) in Query(world, (Position, Velocity))\n        @inbounds for i in eachindex(entities)\n            pos = positions[i]\n            vel = velocities[i]\n            positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n        end\n    end\nend","category":"section"},{"location":"manual/systems.html#Putting-it-together","page":"Systems","title":"Putting it together","text":"Finally, we can plug everything together:\n\nworld = World(Position, Velocity)\n\nscheduler = Scheduler(\n    world,\n    (\n        InitializerSystem(100),\n        MovementSystem(),\n    ),\n)\n\nrun!(scheduler, 1000)","category":"section"},{"location":"manual/components.html#Components","page":"Components","title":"Components","text":"Components contain the data associated to an Entity, i.e. their properties or state variables.","category":"section"},{"location":"manual/components.html#Component-types","page":"Components","title":"Component types","text":"Components are distinguished by their type, and each entity can only have one component of a certain type.\n\nIn Ark, any type can be used as a component. However, it is highly recommended to use immutable types, because mutable objects are usually allocated on the heap in Julia, which defeats Ark's claim of high performance. Mutable types are disallowed by default, but can be enabled when constructing a World by the optional argument allow_mutable of the world constructor.","category":"section"},{"location":"manual/components.html#Accessing-components","page":"Components","title":"Accessing components","text":"Although the majority of the logic in an application that uses Ark will be performed in Queries, it may be necessary to access components for a particular entity. One or more components of an entity can be accessed via get_components:\n\n(pos, vel) = get_components(world, entity, (Position, Velocity))\n\nSimilarly, the components of an entity can be overwritten by new values via set_components!, which is particularly useful for immutable components (which are the default):\n\nset_components!(world, entity, (Position(0, 0), Velocity(1,1)))","category":"section"},{"location":"manual/components.html#Adding-and-removing-components","page":"Components","title":"Adding and removing components","text":"A feature that makes ECS particularly flexible and powerful is the ability to add components to and remove them from entities at runtime. This works similar to component access and can be done via add_components! and remove_components!:\n\nentity = new_entity!(world, ())\n\nadd_components!(world, entity, (Position(0, 0), Velocity(1,1)))\nremove_components!(world, entity, (Velocity,))\n\nNote that adding an already existing component or removing a missing one results in an error.\n\nAlso note that it is more efficient to add/remove multiple components at once instead of one by one. To allow for efficient exchange of components (i.e. add some and remove others in the same operation), exchange_components! can be used:\n\nentity = new_entity!(world, (Position(0, 0), Velocity(1,1)))\n\nexchange_components!(world, entity; \n    add    = (Health(100),),\n    remove = (Position, Velocity),\n)\n\nFor manipulating entities in batches, add_components!, remove_components! and exchange_components! come with versions that take a filter instead of a single entity as argument. See chapter Batch operations for details.","category":"section"},{"location":"manual/components.html#component-storages","page":"Components","title":"Component storages","text":"Components are stored in archetypes, with the values for each component type stored in a separate array-like column. For these columns, Ark offers two storage modes:\n\nVector storage stores component objects in a simple vector per column. This is the default.\nStructArray storage stores components in an SoA data structure similar to   StructArrays.   This allows access to field vectors in queries, enabling SIMD-accelerated,   vectorized operations and increased cache-friendliness if not all of the component's fields are used.   StructArray storage has some limitations:  \nNot allowed for mutable components.\nNot allowed for components without fields, like labels and primitives.\n≈10-20% runtime overhead for component operations and entity creation.\nSlower component access with get_components and set_components!.\n\nThe storage mode can be selected per component type by using StructArrayStorage or VectorStorage during world construction.\n\nworld = World(\n    Position => VectorStorage,\n    Velocity => StructArrayStorage,\n)\n\nThe default is VectorStorage if no storage mode is specified:\n\nworld = World(\n    Position,\n    Velocity => StructArrayStorage,\n)","category":"section"},{"location":"api.html#API","page":"Public API","title":"API","text":"Ark's public API.\n\nPages = [\"api.md\"]\nDepth = 2:2","category":"section"},{"location":"api.html#world-api","page":"Public API","title":"World","text":"The World is the central data storage for Entities, Components and Resources.","category":"section"},{"location":"api.html#entities-api","page":"Public API","title":"Entities","text":"Entities are the \"game objects\" or \"model entities\". An entity if just an ID with a generation, but Components can be attached to an entity.","category":"section"},{"location":"api.html#components-api","page":"Public API","title":"Components","text":"Components contain the data associated with Entities.","category":"section"},{"location":"api.html#queries-api","page":"Public API","title":"Queries and Filters","text":"Queries are used to filter and process Entities with a certain set of Components.","category":"section"},{"location":"api.html#resources-api","page":"Public API","title":"Resources","text":"Resources are singleton-like data structures that appear only once in a World and are not associated to an Entity.","category":"section"},{"location":"api.html#events-api","page":"Public API","title":"Event system","text":"The event system allows user code to react on structural changes like entity creation and removal and component addition and removal. Further, custom events can be defined and emitted.","category":"section"},{"location":"api.html#Index","page":"Public API","title":"Index","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api.html#Ark.World","page":"Public API","title":"Ark.World","text":"World{CS<:Tuple,CT<:Tuple,ST<:Tuple,N,M}\n\nThe World is the central storage for entities, components and resources.\n\nSee the constructor World for details.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.World-Tuple{Vararg{Type}}","page":"Public API","title":"Ark.World","text":"World(\n    comp_types::Type...;\n    initial_capacity::Int=128,\n    allow_mutable::Bool=false,\n)\n\nCreates a new, empty World for the given component types.\n\nAll component types that will be used with the world must be specified. This allows Ark to use Julia's compile-time method generation to achieve the best performance.\n\nFor each component type, an individual storage mode can be set. See also VectorStorage and StructArrayStorage.\n\nAdditional arguments can be used to allow mutable component types (forbidden by default and discouraged) and an initial capacity for entities in archetypes.\n\nArguments\n\ncomp_types: The component types used by the world.\ninitial_capacity: Initial capacity for entities in each archetype and in the entity index.\nallow_mutable: Allows mutable components. Use with care, as all mutable objects are heap-allocated in Julia.\n\nExamples\n\nA World where all components use the default storage mode:\n\nworld = World(\n    Position,\n    Velocity,\n)\n\nA World with individually configured storage modes:\n\nworld = World(\n    Position => StructArrayStorage,\n    Velocity => StructArrayStorage,\n    Health => VectorStorage,\n)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.reset!","page":"Public API","title":"Ark.reset!","text":"reset!(world::World)\n\nRemoves all entities and resources from the world, and un-registers all observers. Does NOT free reserved memory or remove archetypes.\n\nCan be used to run systematic simulations without the need to re-allocate memory for each run. Accelerates re-populating the world by a factor of 2-3.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.is_locked","page":"Public API","title":"Ark.is_locked","text":"is_locked(world::World)::Bool\n\nReturns whether the world is currently locked for modifications.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.StructArrayStorage","page":"Public API","title":"Ark.StructArrayStorage","text":"StructArrayStorage\n\nMarks component types for using StructArray-like storage mode in the world constructor.\n\nIn StructArray storages, mutable components are not allowed.\n\nSee also VectorStorage.\n\nExample\n\nworld = World(\n    Position => StructArrayStorage,\n    Velocity => StructArrayStorage,\n)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.VectorStorage","page":"Public API","title":"Ark.VectorStorage","text":"VectorStorage\n\nMarks component types for using Vector storage mode in the world constructor. As this is the default storage mode if the storage type is not specified.\n\nSee also StructArrayStorage.\n\nExample\n\nworld = World(\n    Position => VectorStorage,\n    Velocity => VectorStorage,\n)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.Relationship","page":"Public API","title":"Ark.Relationship","text":"Relationship\n\nAbstract marker type for relationship components.\n\nExample\n\nstruct ChildOf <: Relationship end\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.Entity","page":"Public API","title":"Ark.Entity","text":"Entity\n\nEntity identifier.\n\nEntities can be constructed using a World via new_entity! and new_entities!.\n\nEntities can be safely stored in components and resources.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.zero_entity","page":"Public API","title":"Ark.zero_entity","text":"const zero_entity::Entity\n\nThe reserved zero Entity value. Can be used to represent \"no entity\"/\"nil\".\n\n\n\n\n\n","category":"constant"},{"location":"api.html#Ark.new_entity!","page":"Public API","title":"Ark.new_entity!","text":"new_entity!(world::World, values::Tuple; relations::Tuple=())::Entity\n\nCreates a new Entity with the given component values. Types are inferred from the values.\n\nArguments\n\nworld::World: The World instance to use.\nvalues::Tuple: Component values for the entity.\ndefaults::Tuple: A tuple of default values for initialization, like (Position(0, 0), Velocity(1, 1)).\nrelations::Tuple: Relationship component type => target entity pairs.\n\nExamples\n\nCreate an entity with components:\n\nentity = new_entity!(world, (Position(0, 0), Velocity(1, 1)))\n\nCreate an entity with components and relationships:\n\nentity = new_entity!(world, (Position(0, 0), ChildOf()); relations=(ChildOf => parent,))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.new_entities!","page":"Public API","title":"Ark.new_entities!","text":"new_entities!(\n    [f::Function],\n    world::World,\n    n::Int,\n    components::Tuple;\n    relations:Tuple=(),\n)\n\nCreates the given number of entities. Components can be given as types or as default values. In the latter case, types are inferred from the add values.\n\nA callback/do-block can be run on the newly created entities e.g. for individual initialization. It takes a tuple of (entities, columns...) as argument, with a column for each added component. The callback is mandatory if components are given as types. Note that components are not initialized/undef unless set in the callback in this case.\n\nArguments\n\nf::Function: Optional callback for initialization, can be passed as a do block.\nworld::World: The World instance to use.\nn::Int: The number of entities to create.\ncomponents::Tuple: A tuple of component to add. Either default values like (Position(0, 0), Velocity(1, 1)), or types like (Position, Velocity).\nrelations::Tuple: Relationship component type => target entity pairs.\niterate::Bool: Whether to return a batch for individual entity initialization.\n\nExamples\n\nCreate 100 entities from default values:\n\nnew_entities!(world, 100, (Position(0, 0), Velocity(1, 1)))\n\nCreate 100 entities from component types and initialize them:\n\nnew_entities!(world, 100, (Position, Velocity)) do (entities, positions, velocities)\n    for i in eachindex(entities)\n        positions[i] = Position(rand(), rand())\n        velocities[i] = Velocity(1, 1)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.remove_entity!","page":"Public API","title":"Ark.remove_entity!","text":"remove_entity!(world::World, entity::Entity)\n\nRemoves an Entity from the World.\n\nExample\n\nremove_entity!(world, entity)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.remove_entities!","page":"Public API","title":"Ark.remove_entities!","text":"remove_entities!([f::Function], world::World, filter::Filter)\n\nRemoves all entities that match the given Filter from the World.\n\nThe optional callback/do block is called on them before the removal. The callback's argument is an Entities list.\n\nExample\n\nRemoving entities:\n\nfilter = Filter(world, (Position, Velocity))\nremove_entities!(world, filter)\n\nRemoving entities using a callback:\n\nfilter = Filter(world, (Position, Velocity))\nremove_entities!(world, filter) do entities\n    # do something with the entities.\nend\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.copy_entity!","page":"Public API","title":"Ark.copy_entity!","text":"copy_entity!(\n    world::World,\n    entity::Entity;\n    add::Tuple=(),\n    remove::Tuple=(),\n    relations::Tuple=(),\n    mode=:copy,\n)\n\nCopies an Entity, optionally adding and/or removing components.\n\nMutable and non-isbits components are shallow copied by default. This can be changed with the mode argument.\n\nArguments\n\nworld: The World instance to query.\nentity::Entity: The entity to copy.\nadd::Tuple: Components to add, like with=(Health(0),).\nremove::Tuple: Component types to remove, like (Position,Velocity).\nrelations::Tuple: Relationship component type => target entity pairs.\nmode::Tuple: Copy mode for mutable and non-isbits components. Modes are :ref, :copy, :deepcopy.\n\nExamples\n\nSimple copy of an entity:\n\nentity1 = copy_entity!(world, entity)\n\nCopy an entity, adding and removing some components in the same operation:\n\nentity2 = copy_entity!(world, entity;\n    add=(Health(100),),\n    remove=(Position, Velocity),\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.is_alive","page":"Public API","title":"Ark.is_alive","text":"is_alive(world::World, entity::Entity)::Bool\n\nReturns whether an Entity is alive.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.is_zero","page":"Public API","title":"Ark.is_zero","text":"is_zero(entity::Entity)::Bool\n\nReturns whether an Entity is the reserved zero_entity.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.get_components","page":"Public API","title":"Ark.get_components","text":"get_components(world::World, entity::Entity, comp_types::Tuple)\n\nGet the given components for an Entity. Components are returned as a tuple.\n\nExample\n\npos, vel = get_components(world, entity, (Position, Velocity))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.has_components","page":"Public API","title":"Ark.has_components","text":"has_components(world::World, entity::Entity, comp_types::Tuple)::Bool\n\nReturns whether an Entity has all given components.\n\nExample\n\nhas = has_components(world, entity, (Position, Velocity))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.set_components!","page":"Public API","title":"Ark.set_components!","text":"set_components!(world::World, entity::Entity, values::Tuple)\n\nSets the given component values for an Entity. Types are inferred from the values. The entity must already have all these components.\n\nExample\n\nset_components!(world, entity, (Position(0, 0), Velocity(1, 1)))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.add_components!","page":"Public API","title":"Ark.add_components!","text":"add_components!(world::World, entity::Entity, values::Tuple; relations::Tuple)\n\nAdds the given component values to an Entity. Types are inferred from the values.\n\nExample\n\nadd_components!(world, entity, (Health(100),))\n\n\n\n\n\nadd_components!(\n    [f::Function]\n    world::World,\n    filter::Filter,\n    add::Tuple=(),\n    relations::Tuple=(),\n)\n\nAdds components to all entities matching the given Filter.\n\nComponents can be added as types or as values. In the latter case, types are inferred from the add values.\n\nA callback/do-block can be run on the affected entities e.g. for individual initialization. It takes a tuple of (entities, columns...) as argument, with a column for each added component. The callback is mandatory if components are added as types. Note that components are not initialized/undef unless set in the callback in this case.\n\nArguments\n\nf::Function: Optional callback for initialization, can be passed as a do block.\nworld::World: The World instance to use.\nfilter::Filter: The Filter to select entities.\nadd::Tuple: A tuple of component to add. Either default values like (Position(0, 0), Velocity(1, 1)), or types like (Position, Velocity).\nrelations::Tuple: Relationship component type => target entity pairs.\n\nExamples\n\nAdding values, not using the callback:\n\nfilter = Filter(world, (Velocity,))\nadd_components!(world, filter, (Health(100),))\n\nAdding as types, using the callback for initialization:\n\nfilter = Filter(world, (Velocity,))\nadd_components!(world, filter, (Health,)) do (entities, healths)\n    for i in eachindex(entities, healths)\n        healths[i] = Health(i * 2)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.remove_components!","page":"Public API","title":"Ark.remove_components!","text":"remove_components!(world::World, entity::Entity, comp_types::Tuple)\n\nRemoves the given components from an Entity.\n\nExample\n\nremove_components!(world, entity, (Position, Velocity))\n\n\n\n\n\nremove_components!(\n    [f::Function]\n    world::World,\n    filter::Filter,\n    remove::Tuple=(),\n)\n\nRemoves components from all entities matching the given Filter.\n\nA callback/do-block can be run on the affected entities. It takes an entities column as argument.\n\nArguments\n\nf::Function: Optional callback for initialization, can be passed as a do block.\nworld::World: The World instance to use.\nfilter::Filter: The Filter to select entities.\nremove::Tuple: A tuple of component types to remove, like (Position, Velocity)\n\nExamples\n\nRemoving components, not using the callback:\n\nfilter = Filter(world, (Velocity,))\nremove_components!(world, filter, (Velocity,))\n\nRemoving components, using the optional callback:\n\nfilter = Filter(world, (Velocity,))\nremove_components!(world, filter, (Velocity,)) do entities\n    # do something with the entities...\nend\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.exchange_components!","page":"Public API","title":"Ark.exchange_components!","text":"exchange_components!(\n    world::World,\n    entity::Entity;\n    add::Tuple=(),\n    remove::Tuple=(),\n    relations::Tuple=(),\n)\n\nAdds and removes components on an Entity. Types are inferred from the add values.\n\nExample\n\nexchange_components!(world, entity;\n    add=(Health(100),),\n    remove=(Position, Velocity),\n)\n\n\n\n\n\nexchange_components!(\n    [f::Function]\n    world::World,\n    filter::Filter;\n    add::Tuple=(),\n    remove::Tuple=(),\n    relations::Tuple=(),\n)\n\nAdds and removes components on all entities matching the given Filter.\n\nComponents can be added as types or as values. In the latter case, types are inferred from the add values.\n\nA callback/do-block can be run on the affected entities e.g. for individual initialization. It takes a tuple of (entities, columns...) as argument, with a column for each added component. The callback is mandatory if components are added as types. Note that components are not initialized/undef unless set in the callback in this case.\n\nArguments\n\nf::Function: Optional callback for initialization, can be passed as a do block.\nworld::World: The World instance to use.\nfilter::Filter: The Filter to select entities.\nadd::Tuple: A tuple of component to add. Either default values like (Position(0, 0), Velocity(1, 1)), or types like (Position, Velocity).\nremove::Tuple: A tuple of component types to remove, like (Position, Velocity)\nrelations::Tuple: Relationship component type => target entity pairs.\n\nExamples\n\nAdding values, not using the callback:\n\nfilter = Filter(world, (Velocity,))\nexchange_components!(world, filter;\n    add=(Health(100),),\n    remove=(Velocity,),\n)\n\nAdding as types, using the callback for initialization:\n\nfilter = Filter(world, (Velocity,))\nexchange_components!(world, filter;\n    add=(Health,),\n    remove=(Velocity,),\n) do (entities, healths)\n    for i in eachindex(entities, healths)\n        healths[i] = Health(i * 2)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.get_relations","page":"Public API","title":"Ark.get_relations","text":"get_relations(world::World, entity::Entity, comp_types::Tuple)\n\nGet the relation targets for components of an Entity. Targets are returned as a tuple.\n\nExample\n\nparent, = get_relations(world, entity, (ChildOf,))\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.set_relations!","page":"Public API","title":"Ark.set_relations!","text":"set_relations!(world::World, entity::Entity, relations::Tuple)\n\nSets relation targets for the given components of an Entity. The entity must already have all these relationship components.\n\nExample\n\nset_relations!(world, entity, (ChildOf => parent,))\n\n\n\n\n\nset_relations!([f::Function], world::World, filter::Filter::Entity, relations::Tuple)\n\nSets relation targets for the given components of all entities matching the given Filter. Optionally runs a callback/do-block on the affected entities.\n\nExample\n\nSetting relation targets:\n\nfilter = Filter(world, (ChildOf,); relations=(ChildOf => parent,))\nset_relations!(world, filter, (ChildOf => parent2,))\n\nSetting relation targets and running a callback:\n\nfilter = Filter(world, (ChildOf,); relations=(ChildOf => parent,))\nset_relations!(world, filter, (ChildOf => parent2,)) do entities\n    # do something with the entities...\nend\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.Query","page":"Public API","title":"Ark.Query","text":"Query\n\nA query for components. See function Query for details.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.Query-Tuple{World, Tuple}","page":"Public API","title":"Ark.Query","text":"Query(\n    world::World,\n    comp_types::Tuple;\n    with::Tuple=(),\n    without::Tuple=(),\n    optional::Tuple=(),\n    exclusive::Bool=false,\n    relations::Tuple=(),\n)\n\nCreates a query.\n\nA query is an iterator for processing all entities that match the query's criteria. The query itself iterates matching archetypes, while an inner loop or broadcast operations must be used to manipulate individual entities (see example below).\n\nA query locks the World until it is fully iterated or closed manually. This prevents structural changes like creating and removing entities or adding and removing components during the iteration.\n\nSee the user manual chapter on Queries for more details and examples.\n\nArguments\n\nworld: The World instance to query.\ncomp_types::Tuple: Components the query filters for and provides access to.\nwith::Tuple: Additional components the entities must have.\nwithout::Tuple: Components the entities must not have.\noptional::Tuple: Additional components that are optional in the query.\nexclusive::Bool: Makes the query exclusive in base and with components, can't be combined with without.\nrelations::Tuple: Relationship component type => target entity pairs. These relation components must be in the query's components or with.\n\nExample\n\nfor (entities, positions, velocities) in Query(world, (Position, Velocity))\n    for i in eachindex(entities)\n        pos = positions[i]\n        vel = velocities[i]\n        positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.Query-Tuple{Filter}","page":"Public API","title":"Ark.Query","text":"Query(filter::Filter)\n\nCreates a query from a Filter.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.close!-Tuple{Query}","page":"Public API","title":"Ark.close!","text":"close!(q::Query)\n\nCloses the query and unlocks the world.\n\nMust be called if a query is not fully iterated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.Filter","page":"Public API","title":"Ark.Filter","text":"Filter\n\nA filter for components. See function Filter for details. See also Query.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.Filter-Tuple{World, Tuple}","page":"Public API","title":"Ark.Filter","text":"Filter(\n    world::World,\n    comp_types::Tuple;\n    with::Tuple=(),\n    without::Tuple=(),\n    optional::Tuple=(),\n    exclusive::Bool=false,\n    relations::Tuple=(),\n    register::Bool=false,\n)\n\nCreates a filter. Filters are similar to queries, but can't be iterated directly. They are a re-usable way to define query filtering criteria, and can be registered for faster, cached queries. Further, filters are used in batch operations.\n\nSee the user manual chapter on Queries for more details and examples.\n\nArguments\n\nworld: The World instance to filter.\ncomp_types::Tuple: Components the filter filters for.\nwith::Tuple: Additional components the entities must have.\nwithout::Tuple: Components the entities must not have.\noptional::Tuple: Additional components that are optional in the filter.\nexclusive::Bool: Makes the filter exclusive in base and with components, can't be combined with without.\nrelations::Tuple: Relationship component type => target entity pairs. These relation components must be in the filter's components or with.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.unregister!","page":"Public API","title":"Ark.unregister!","text":"unregister!(world::World, filter::Filter)\n\nUn-registers a Filter.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.count_entities","page":"Public API","title":"Ark.count_entities","text":"count_entities(f::Filter)\n\nReturns the number of matching entities in the filter.\n\nnote: Note\nThe time complexity is linear with the number of archetypes in the filter's pre-selection. It is equivalent to iterating the filter's archetypes and summing up their lengths.\n\n\n\n\n\ncount_entities(q::Query)\n\nReturns the number of matching entities in the query.\n\nDoes not iterate or close! the query.\n\nnote: Note\nThe time complexity is linear with the number of archetypes in the query's pre-selection. It is equivalent to iterating the query's archetypes and summing up their lengths.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.length","page":"Public API","title":"Base.length","text":"length(f::Filter)\n\nReturns the number of matching tables with at least one entity in the filter.\n\nnote: Note\nThe time complexity is linear with the number of tables in the filter's pre-selection.\n\n\n\n\n\nlength(q::Query)\n\nReturns the number of matching tables with at least one entity in the query.\n\nDoes not iterate or close! the query.\n\nnote: Note\nThe time complexity is linear with the number of tables in the query's pre-selection.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.Entities","page":"Public API","title":"Ark.Entities","text":"Entities\n\nArchetype column for entities. Can be iterated and indexed like a Vector, but is read-only.\n\nUsed in query iteration and batch operations callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.@unpack","page":"Public API","title":"Ark.@unpack","text":"@unpack ...\n\nUnpacks the tuple returned from a Query during iteration into field vectors. Field vectors are particularly useful for StructArrayStorages, but can also be used with VectorStorages, although those are currently not equally efficient in broadcasted operations.\n\nColumns for components without fields, like primitives or label components, fall through @unpack unaltered.\n\nSee also unpack(::StructArrayView) and unpack(::FieldViewable).\n\nExample\n\nfor columns in Query(world, (Position, Velocity))\n    @unpack entities, (x, y), (dx, dy) = columns\n    @inbounds x .+= dx\n    @inbounds y .+= dy\nend\n\n\n\n\n\n","category":"macro"},{"location":"api.html#Ark.unpack","page":"Public API","title":"Ark.unpack","text":"unpack(a::StructArrayView)\n\nUnpacks the components (i.e. field vectors) of a StructArrayStorage column returned from a Query. See also @unpack.\n\n\n\n\n\nunpack(a::FieldViewable)\n\nUnpacks the components (i.e. field vectors) of a VectorStorage column returned from a Query. See also @unpack.\n\nnote: Note\nSetting values on unpacked non-isbits fields of immutable components has a certain overhead, as the underlying struct needs to be reconstructed and written to memory. See\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.get_resource","page":"Public API","title":"Ark.get_resource","text":"get_resource(world::World, res_type::Type{T})::T\n\nGet the resource of type T from the world.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.has_resource","page":"Public API","title":"Ark.has_resource","text":"has_resource(world::World, res_type::Type{T})::Bool\n\nCheck if a resource of type T is in the world.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.add_resource!","page":"Public API","title":"Ark.add_resource!","text":"add_resource!(world::World, res::T)::T\n\nAdd the given resource to the world. Returns the newly added resource.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.set_resource!","page":"Public API","title":"Ark.set_resource!","text":"set_resource!(world::World, res::T)::T\n\nOverwrites an existing resource in the world. Returns the newly overwritten resource.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.remove_resource!","page":"Public API","title":"Ark.remove_resource!","text":"remove_resource!(world::World, res_type::Type{T})::T\n\nRemove the resource of type T from the world. Returns the removed resource.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.EventType","page":"Public API","title":"Ark.EventType","text":"EventType\n\nType for built-in and custom events. See EventRegistry for creating custom event types.\n\nBuilt-in event types\n\nOnCreateEntity: Event emitted after a new entity is created.\nOnRemoveEntity: Event emitted before an entity is removed from the World.\nOnAddComponents: Event emitted after components are added to an entity.\nOnRemoveComponents: Event emitted before components are removed from an entity.\nOnAddRelations: Event emitted after relation targets are added to an entity. Includes creating entities, adding components as well as setting relation targets.\nOnRemoveRelations: Event emitted before relation targets are removed from an entity. Includes removing entities, removing components as well as setting relation targets.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.EventRegistry","page":"Public API","title":"Ark.EventRegistry","text":"EventRegistry\n\nServes for creating custom event types.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.EventRegistry-Tuple{}","page":"Public API","title":"Ark.EventRegistry","text":"EventRegistry()\n\nCreates a new EventRegistry.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Ark.new_event_type!","page":"Public API","title":"Ark.new_event_type!","text":"new_event_type!(reg::EventRegistry, symbol::Symbol)\n\nCreates a new custom EventType. Custom event types are best stored in global constants.\n\nThe symbol is only used for printing.\n\nExample\n\nregistry = EventRegistry()\nconst OnGameOver = new_event_type!(registry, :OnGameOver)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.Observer","page":"Public API","title":"Ark.Observer","text":"Observer\n\nObserver for reacting on built-in and custom events.\n\nSee observe! for details. See EventType for built-in, and EventRegistry for custom event types.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Ark.observe!","page":"Public API","title":"Ark.observe!","text":"observe!(\n    fn::Function,\n    world::World,\n    event::EventType,\n    components::Tuple=();\n    with::Tuple=(),\n    without::Tuple=(),\n    exclusive::Bool=false,\n    register::Bool=true,\n)\n\nCreates an Observer and (optionally, default) registers it.\n\nSee EventType for built-in, and EventRegistry for custom event types.\n\nArguments\n\nfn::Function: A callback function to execute when a matching event is received. Can be used via a do block.\nworld::World: The World to observe.\nevent::EventType: The EventType to observe.\ncomponents::Tuple=(): The component types to observe. Must be empty for OnCreateEntity and OnRemoveEntity.\nwith::Tuple=(): Components the entity must have.\nwithout::Tuple=(): Components the entity must not have.\nexclusive::Bool=false: Makes the observer exclusive for entities that have exactly the components given be with.\nregister::Bool=true: Whether the observer is registered immediately. Alternatively, register later with observe!\n\nExample\n\nobserve!(world, OnAddComponents, (Position, Velocity); with=(Altitude,)) do entity\n    println(entity)\nend\n\n\n\n\n\nobserve!(world::World, observer::Observer; unregister::Bool=false)\n\nRegisters or un-registers the given Observer. Note that observers created with observe! are automatically registered by default.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ark.emit_event!","page":"Public API","title":"Ark.emit_event!","text":"emit_event!(world::World, event::EventType, entity::Entity, components::Tuple=())\n\nEmits a custom event for the given EventType, Entity and optional components. The entity must have the given components. The entity can be the reserved zero_entity.\n\nworld::World: The World to emit the event.\nevent::EventType: The EventType to emit.\nentity::Entity: The Entity to emit the event for.\ncomponents::Tuple=(): The component types to emit the event for. Optional.\n\nExample\n\nemit_event!(world, OnCollisionDetected, entity, (Position, Velocity))\n\n\n\n\n\n","category":"function"},{"location":"manual/queries.html#Queries","page":"Queries","title":"Queries","text":"Queries allow to select Entities that have a certain set of Components and to manipulate them.\n\nQueries are the heart of every ECS and the main reason for its flexibility and performance. In Ark, queries are blazing fast and should be used to write the game or model logic where possible. For cases where components of a particular entity are required, see section Accessing components.","category":"section"},{"location":"manual/queries.html#Basic-queries","page":"Queries","title":"Basic queries","text":"By default, a Query iterates over all entities that have the query's components, and provides efficient access to these components.\n\nHere, we are interested only in non-exclusive sets. So the entities that are processed may have further components, but these are not of interest for that particular piece of game or model logic.\n\nfor (entities, positions, velocities) in Query(world, (Position, Velocity))\n    @inbounds for i in eachindex(entities)\n        pos = positions[i]\n        vel = velocities[i]\n        positions[i] = Position(pos.x + vel.dx, pos.y + vel.dy)\n    end\nend\n\nNote the nested loop! In the outer loop, the query iterates the archetypes, and for each one returns a vector of entities and the columns for the queried components. In the inner loop, we iterate over the entities within the archetype and perform the actual logic.\n\nAlso note the last line in the inner loop. Here, we assign a new Position value to the current entity. This is necessary as Position is immutable, which is the default and highly recommended. See section Component types for details.\n\nThe @inbounds macro in front of the inner loop is optional, but it is safe to use here and makes the iteration faster as it allows the compiler to skip bounds checks.","category":"section"},{"location":"manual/queries.html#Advanced-queries","page":"Queries","title":"Advanced queries","text":"Query filters can be configured further, to include or exclude additional components.","category":"section"},{"location":"manual/queries.html#with","page":"Queries","title":"with","text":"Queries provide an optional with argument that filters for additional components that entities must have, but that are not used by the query.\n\nfor (entities, positions, velocities) in Query(world,\n            (Position, Velocity);\n            with=(Health,)\n        )\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"section"},{"location":"manual/queries.html#without","page":"Queries","title":"without","text":"The optional without argument allows to exclude entities that have certain components:\n\nfor (entities, positions, velocities) in Query(world,\n            (Position, Velocity);\n            without=(Health,)\n        )\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"section"},{"location":"manual/queries.html#exclusive","page":"Queries","title":"exclusive","text":"The optional exclusive argument excludes entities that have any other then the query's components and those specified by with. So it acts like an exhaustive without:\n\nfor (entities, positions, velocities) in Query(world,\n            (Position, Velocity);\n            exclusive=true\n        )\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend","category":"section"},{"location":"manual/queries.html#optional","page":"Queries","title":"optional","text":"The optional optional argument adds optional component. 😉\n\nEntities are included irrespective of presence of these components on them. Columns for these components are added at the end of the query iterator tuple. They are nothing if the current archetype does not have them.\n\nfor (entities, positions, velocities, healths) in Query(world,\n            (Position, Velocity);\n            optional=(Health,)\n        )\n    has_healths = healths !== nothing\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend\n\nNote that it is possible to branch already outside of the inner loop, as all entities in an archetype either have a component or don't.","category":"section"},{"location":"manual/queries.html#filter-caching","page":"Queries","title":"Filter caching","text":"With normal queries as shown above, archetypes and relationship tables are matched against filter masks during query iteration. For large numbers of archetypes, this has a certain overhead, although archetypes are pre-selected based on the most \"rare\" queried component.\n\nTo speed up query iteration for a large number of archetypes, Ark provides filter caching. With cached/registered filters, archetypes and tables are only matched against masks at their creation, but not during query iteration.\n\nThis example shows how to use registered filters:\n\n# A registered filter. Store it permanently and re-use it!\nfilter = Filter(world, (Position, Velocity); register=true)\n\n# The actual query iteration.\nfor (entities, positions, velocities) in Query(filter)\n    @inbounds for i in eachindex(entities)\n        # ...\n    end\nend\n\nnote: Note\nRegistering filters only makes sense when they are stored permanently (e.g. in a System) and re-used for query creation.\n\nFilters support all keyword arguments of queries (see above).\n\nA registered filter can be un-registered like this:\n\nunregister!(filter)","category":"section"},{"location":"manual/queries.html#Component-field-views","page":"Queries","title":"Component field views","text":"Individual fields of components can be accessed as vectors in queries, e.g. using @unpack. This is particularly useful for components that use the StructArray storage modes, as it allows for SIMD-accelerated vectorized operations.\n\nworld = World(\n    Position => StructArrayStorage,\n    Velocity => StructArrayStorage,\n)\n\n# ...\n\nfor columns in Query(world, (Position, Velocity))\n    @unpack entities, (x, y), (dx, sy) = columns\n    @inbounds x .+= dx\n    @inbounds y .+= dy\nend\n\nHowever, when iterating components that use StructArray storage without unpacking individual fields, there is a certain overhead and SIMD optimization may not be possible.\n\nNote that it is also possible to access field vectors by the field's name:\n\nfor (_, positions, velocities) in Query(world, (Position, Velocity))\n    @inbounds positions.x .+= velocities.dx\n    @inbounds positions.y .+= velocities.dy\nend","category":"section"},{"location":"manual/queries.html#world-lock","page":"Queries","title":"World lock","text":"During query iteration, the World is locked for modifications like entity creation and removal and component addition and removal. This is necessary to prevent changes to the inner storage structure of the World that would result in undefined behavior of the query.\n\nWhenever the game or model logic demands one of these forbidden operations, the entities to be affected must first be collected into a Vector, and the operations must be applied only after the query iteration has finished.\n\n# vector for entities to be removed from te world\nto_remove = Entity[]\n\nfor (entities, positions) in Query(world, (Position,))\n    @inbounds for i in eachindex(entities)\n        pos = positions[i]\n\n        # collect entities for removal\n        if pos.y < 0\n            push!(to_remove, entities[i])\n        end\n    end\nend\n\n# actual removal\nfor entity in to_remove\n    remove_entity!(world, entity)\nend\n\n# clear the vector for re-use\nresize!(to_remove, 0)\n\nFor the best performance, such a Vector should be stored persistently and re-used to avoid repeated memory allocations.\n\nThe world is automatically unlocked when query iteration finishes. When breaking out of a query loop, however, it must be unlocked by calling close! on the query.","category":"section"},{"location":"manual/world.html#The-World","page":"The World","title":"The World","text":"A World is the central data store for any application that uses Ark.jl. It manages Entities, Components and Resources, and all these are always tied to a World.\n\nMost applications will have exactly one world, but multiple worlds can exist at the same time.","category":"section"},{"location":"manual/world.html#World-creation","page":"The World","title":"World creation","text":"When creating a new world, all Component types that can exist in it must be specified.\n\nusing Ark\n\nstruct Position\n    x::Float64\n    y::Float64\nend\n\nstruct Velocity\n    dx::Float64\n    dy::Float64\nend\n\nworld = World(Position, Velocity)\n\nThis may seem unusual, but it allows Ark to leverage Julia's compile-time programming features for the best performance.","category":"section"},{"location":"manual/world.html#Initial-capacity","page":"The World","title":"Initial capacity","text":"The World constructor takes an option keyword argument initial_capacity to allocate memory for the given number of entities in each archetype. This is useful to speed up entity creations by avoiding repeated allocations.\n\nworld = World(Position, Velocity; initial_capacity=1024)","category":"section"},{"location":"manual/world.html#World-reset","page":"The World","title":"World reset","text":"Ark's primary goal is to empower high-performance simulation models. In this domain, it is common to run large numbers of simulations, whether to explore model stochasticity, perform calibration, or for optimization purposes.\n\nTo maximize efficiency, Ark provides a reset! function that resets a simulation world for subsequent reuse. This significantly accelerates model initialization by reusing already allocated memory and avoiding costly reallocation.\n\nreset!(world)","category":"section"},{"location":"manual/world.html#World-functionality","page":"The World","title":"World functionality","text":"You will see that almost all methods in Ark's API take a World as their first argument. These methods are explained in the following chapters.","category":"section"},{"location":"manual/architecture.html#Architecture","page":"Architecture","title":"Architecture","text":"This chapter describes the principles of Ark's architecture, which may be useful to understand what is actually going on, and to understand performance trade-offs.","category":"section"},{"location":"manual/architecture.html#archetypes","page":"Architecture","title":"Archetypes","text":"Ark uses an archetype-based architecture (therefore its name).\n\nAn archetype represents a unique combination of components. Each archetype stores the data for all entities that share exactly that combination. You can think of an archetype as a table, where rows correspond to entities and columns represent components. The first column always contains the entity identifiers themselves.\n\nThe ASCII graph below illustrates the approach. The first column shows the entity index, which is used for World component access. The second columns shows archetypes. In this example, the first archetype contains all entities with components A, B and C. The second archetype contains all entities with A and B, and so on. The first column of each archetype contains the entity identifier for each row.\n\n Entities   Archetypes   Bitmasks   Component index\n                                    .-----------.\n                                    | A | B | C |\n   E         E Comps                '-----------'\n  |0|       |2|A|B|C|    111... <-----|<--|<--|\n  |1|---.   |8|A|B|C|                 |   |   |\n  |2|   '-->|1|A|B|C|                 |   |   |\n  |3|       |3|A|B|C|                 |   |   |\n  |4|                                 |   |   |\n  |6|   .-->|7|A|B|      110... <-----'<--|   |\n  |7|---'   |6|A|B|                       |   |\n  |8|       |4|A|B|                       |   |\n  |9|---.                                 |   |\n  |.|   |   |5|B|C|      011... <---------'<--'\n  |.|   '-->|9|B|C|\n  |.|\n  |.| <===> [Entity pool]\n\nIllustration of Ark's archetype-based architecture.\n\nEach archetype has a bit mask (3rd column) that encodes its components and serves for fast checks in queries. Finally, the last column shows the component index. See the next section for details.","category":"section"},{"location":"manual/architecture.html#architecture-queries","page":"Architecture","title":"Queries","text":"Queries serve for iterating and manipulating all entities that have certain components. With the architecture presented here, queries are particularly fast for several reasons:\n\nQueries make a pre-selection of relevant archetypes using the component index, based on the most \"rare\" component.\nQueries do a fast bit mask check per archetype in the pre-selection.\nOnce an archetype is checked as matching, entities in that archetype can be iterated linearly without further checks.\nComponents are stored in array-like columns per archetype, so only the necessary component data needs to be loaded into the CPU cache.\n\nIn worlds with a large number of archetypes, query performance can be further improved by filter caching.","category":"section"},{"location":"manual/architecture.html#component-access","page":"Architecture","title":"World component access","text":"To retrieve components for a specific entity outside query iteration (get_components), the World maintains a list indexed by entity ID (the entity index at the very left in the graph above). Each entry in this list points to the entity's archetype and the position within the archetype's table.\n\nThis setup enables fast random access to component data, though slightly slower than query-based iteration due to the additional indirection.\n\nNote that the entity index also contains entities that are currently not alive, because they were removed from the World. These entities are recycled when new entities are requested from the world. Therefore, besides the ID shown in the illustration, each entity also has a generation variable. It is incremented on each \"reincarnation\", which allows to distinguish recycled from dead entities, as well as from previous or later \"incarnations\".","category":"section"},{"location":"manual/architecture.html#architecture-relationships","page":"Architecture","title":"Entity relationships","text":"Earlier, archetypes were described as flat tables. However, with Ark’s Entity relationships feature, archetypes can contain multiple sub-tables, each corresponding to a unique combination of relation targets.\n\nAs an example, we have components A, B and R, where R is a relation. Further, we have two parent entities E1 and E2. When you create some entities with components A B R(E1) and A B R(E2), i.e. with relation targets E1 and E2, the following archetype is created:\n\n  Archetype [ A B R ]\n    |\n    |--- E1   E Comps\n    |        |3|A|B|R|\n    |        |6|A|B|R|\n    |        |7|A|B|R|\n    |\n    '--- E2   E Comps\n             |4|A|B|R|\n             |5|A|B|R|\n\nRelationship tables of an archetype\n\nWhen querying without specifying a target, the archetype's tables are simply iterated if the archetype matches the filter. When querying with a relation target (and the archetype matches), the table for the target entity is looked up in a standard Dict.\n\nIf the archetype contains multiple relation components, a Dict lookup is used to get all tables matching the target that is specified first. These tables are simply iterated if no further target is specified. If more than one target is specified, the selected tables are checked for these further targets and skipped if they don't match.","category":"section"},{"location":"manual/architecture.html#Archetype-removal","page":"Architecture","title":"Archetype removal","text":"Normal archetype tables without a relation are never removed, because they are not considered temporary. For relation archetypes, however, things are different. Once a target entity dies, it will never appear again (actually it could, after dying another 4,294,967,294 times).\n\nIn Ark, empty tables with a dead relationship target are recycled. They are deactivated, but their allocated memory for entities and components is retained. When a table in the same archetype, but for another target entity is requested, a recycled table is reused if available. To be able to efficiently detect whether a table can be removed, a bitset is used to keep track of entities that are the target of a relationship.","category":"section"},{"location":"manual/architecture.html#Performance-implications","page":"Architecture","title":"Performance implications","text":"Archetypes are primarily designed to maximize iteration speed by grouping entities with identical component sets into tightly packed memory layouts. This structure enables blazing-fast traversal and component access during queries.\n\nHowever, this optimization comes with a trade-off: Adding or removing components from an entity, as well as setting relationship targets, requires relocating it to a different archetype, essentially moving all of its component data. This operation typically costs ≈20ns per involved component, plus some baseline cost.\n\nTo reduce the number of archetype changes, it is recommended to add/remove/exchange multiple components at the same time rather than one after the other. Further, operations can be batched to manipulate many entities in a single command.\n\nFor detailed benchmarks and performance metrics, refer to the Benchmarks chapter.","category":"section"},{"location":"manual/relations.html#Entity-relationships","page":"Entity relationships","title":"Entity relationships","text":"In a basic ECS, relations between entities, like hierarchies, can be represented by storing entities in components. E.g., we could have a child component like this:\n\nstruct ChildOf\n    parent::Entity\nend\n\nOr, alternatively, a parent component with many children:\n\nstruct Parent\n    children::Vector{Entity}\nend\n\nThis may be sufficient for many use cases. However, we are not able to leverage the power of queries to e.g. get all children of a particular parent in an efficient way.\n\nTo make entity relations even more useful and efficient, Ark.jl supports them as a first class feature. Relations are added to and removed from entities just like components, and hence can be queried like components, with the usual efficiency. This is achieved by creating separate sub-tables inside archetypes for relations with different target entities.","category":"section"},{"location":"manual/relations.html#Relation-components","page":"Entity relationships","title":"Relation components","text":"To use entity relations, create components that are sub-types of the abstract marker type Relationship:\n\nstruct ChildOf <: Relationship\nend\n\nThat's all to make a component be treated as an entity relationship by Ark. Relation components can contain variables/fields like usual components, but in many cases they will just be empty structs.","category":"section"},{"location":"manual/relations.html#Creating-relations","page":"Entity relationships","title":"Creating relations","text":"All functions that create or add components take a keyword argument relations that allows to specify target entities for relationship components using tuples of Type => Entity pairs.","category":"section"},{"location":"manual/relations.html#On-new-entities","page":"Entity relationships","title":"On new entities","text":"To create an entity with relations, add a relationship component and specify it's target entity using new_entity!:\n\nentity = new_entity!(world, \n                     (Position(0, 0), ChildOf());\n                     relations=(ChildOf => parent,))\n\nThis works in the same way for batch entity creation with new_entities!.\n\nMultiple relationships can be used in a similar way:\n\nentity = new_entity!(world, \n                     (Position(0, 0), ChildOf(), RenderLayer());\n                     relations=(ChildOf => parent, RenderLayer => layer1))\n\nNote that, when creating entities with relationship components, targets for all relations must be specified.","category":"section"},{"location":"manual/relations.html#When-adding-components","page":"Entity relationships","title":"When adding components","text":"Relation target must also be given when adding relation components to an entity with add_components!:\n\nadd_components!(world, entity, (ChildOf(),); relations=(ChildOf => parent,))\n\nThe same applies for exchange_components!,","category":"section"},{"location":"manual/relations.html#Get-and-set-relations","page":"Entity relationships","title":"Get and set relations","text":"We can also change the target entity of an already assigned relation component. This is done via set_relations!:\n\nentity = new_entity!(world, \n                     (Position(0, 0), ChildOf());\n                     relations=(ChildOf => parent,))\n\nset_relations!(world, entity, (ChildOf => parent2,))\n\nThis also works for changing the targets of multiple relations in one function call.\n\nTarget entities can be retrieved with get_relations:\n\nentity = new_entity!(world, \n                     (Position(0, 0), ChildOf());\n                     relations=(ChildOf => parent,))\n\nparent_entity, = get_relations(world, entity, (ChildOf,))\n\nNote that get_relations always returns a tuple of entities.\n\nAs with other operations, relation targets can be set in batches. See chapter Batch operations for details.","category":"section"},{"location":"manual/relations.html#Querying-relations","page":"Entity relationships","title":"Querying relations","text":"Queries support filtering for relation targets using the keyword argument relations in the same way as already shown:\n\nfor (entities, children) in Query(world, (ChildOf,); relations=(ChildOf => parent,))\n    # ...\nend\n\nIn many use cases, relation components don't contain any data. Here, component values are not required in the query iteration. It is thus sufficient to have the relation component in the query's with:\n\nfor (entities,) in Query(world, (); with=(ChildOf,), relations=(ChildOf => parent,))\n    # ...\nend\n\nNote that when querying for relations without specifying target entities, entities for all targets will be included in the iteration. Similarly, if the targets for some of multiple relations of an entity are not specified, these are treated as wildcards.","category":"section"},{"location":"manual/relations.html#Dead-target-entities","page":"Entity relationships","title":"Dead target entities","text":"Entities that are the target of any relationships can be removed from the world like any other entity. When this happens, all entities that have this target in a relation get assigned to the zero entity as target. The respective archetype sub-table is de-activated and marked for potential re-use for another target entity.","category":"section"},{"location":"manual/relations.html#Limitations","page":"Entity relationships","title":"Limitations","text":"Unlike Flecs, the ECS that pioneered entity relationships, Ark is limited to supporting only \"exclusive\" relationships. This means that any relationship (i.e. relationship type/component) can only have a single target entity. An entity can, however, have multiple different relationship types at the same time.\n\nThe limitation to a single target is mainly a performance consideration. Firstly, the possibility for multiple targets would require a different, slower approach for component mapping in archetypes. Secondly, usage of multiple targets would easily lead to archetype fragmentation, as a separate archetype sub-table would be created for each unique combination of targets.\n\nEntity relationships in Ark are still a very powerful feature, while discouraging use cases where they could easily lead to poor performance. For more details on when entity relationships are the most effective and efficient, see the next section.","category":"section"},{"location":"manual/relations.html#When-to-use,-and-when-not","page":"Entity relationships","title":"When to use, and when not","text":"When using Ark's entity relations, an archetype sub-table is created for each target entity of a relation. Thus, entity relations are not efficient if the number of target entities is high (tens of thousands), while only a low number of entities has a relation to each particular target (less than a few dozens). Particularly in the extreme case of 1:1 relations, storing entities in components as explained in the introduction of this chapter is more efficient.\n\nHowever, with a moderate number of relation targets, particularly with many entities per target, entity relations are very efficient.\n\nBeyond use cases where the relation target is a \"physical\" entity that appears in a simulation or game, targets can also be more abstract, like categories. Examples:\n\nDifferent tree species in a forest model.\nBehavioral states in a finite state machine.\nThe opposing factions in a strategy game.\nRender layers in a game or other graphical application.\n\nThis concept is particularly useful for things that would best be expressed by components, but the possible components (or categories) are only known at runtime. Thus, it is not possible to create ordinary components for them. However, these categories can be represented by entities, which are used as relation targets.","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"<div style=\"text-align: center;\">\n\n<img src=\"assets/ark-logo-text-light.svg\" class=\"only-light\" alt=\"Ark.jl (logo)\" />\n<img src=\"assets/ark-logo-text-dark.svg\" class=\"only-dark\" alt=\"Ark.jl (logo)\" />\n\n(Image: Build Status) (Image: Coverage) (Image: Aqua QA) (Image: JET) (Image: Docs stable) (Image: Docs dev) (Image: GitHub) (Image: DOI:10.5281/zenodo.17512271) (Image: MIT license) (Image: Apache 2.0 license)\n\nArk.jl is an archetype-based Entity Component System (ECS) for Julia. It is a port of the Go ECS Ark.\n\n&mdash;&mdash;\n</div>","category":"section"},{"location":"index.html#Features","page":"Home","title":"Features","text":"Designed for performance and highly optimized.\nWell-documented, type-stable API.\nEntity relationships as a first-class feature.\nStorage mode per component for ergonomics and SIMD.\nExtensible event system with filtering and custom event types.\nFast batch operations for mass manipulation.\nNo systems. Just queries. Use your own structure.\nMinimal dependencies, 100% test coverage.","category":"section"},{"location":"index.html#Why-ECS?","page":"Home","title":"Why ECS?","text":"Entity Component Systems (ECS) offer a clean, scalable way to build individual- and agent-based models by separating agent data from behavioral logic. Agents are simply collections of components, while systems define how those components interact, making simulations modular, extensible, and efficient even with millions of heterogeneous individuals.\n\nArk.jl brings this architecture to Julia with a lightweight, performance-focused implementation that empowers scientific modellers to design complex and performant simulations without the need for deep software engineering expertise.","category":"section"},{"location":"index.html#Manual-Outline","page":"Home","title":"Manual Outline","text":"Quickstart\nThe World\nEntities\nComponents\nQueries\nSystems\nResources\nEntity relationships\nBatch operations\nEvent system\nArchitecture\n\nDemos\n\nBenchmarks","category":"section"},{"location":"index.html#API-Outline","page":"Home","title":"API Outline","text":"Pages = [\"api.md\"]\nDepth = 2:2","category":"section"},{"location":"index.html#API-Index","page":"Home","title":"API Index","text":"Pages = [\"api.md\"]","category":"section"},{"location":"index.html#Cite-as","page":"Home","title":"Cite as","text":"Lange, M. & Meligrana, A. (2025): Ark.jl – An archetype-based Entity Component System for Julia. DOI: 10.5281/zenodo.17512271, GitHub repository: https://github.com/ark-ecs/Ark.jl","category":"section"}]
}
