# ------------------------------------------------------------------------
# ⚠️ This file is auto-generated. DO NOT EDIT.
# Changes will be overwritten by the code generation process.
# ------------------------------------------------------------------------

{{#items}}
"""
    Query{{N}}{ {{joined}} }

A query for {{N}} components.
"""
mutable struct Query{{N}}{ {{joined}} }
    _index::Int
    _world::World
    _ids::Tuple{ {{tuple}} }
    _mask::_Mask
    _exclude_mask::_Mask
    _has_excluded::Bool
    {{#types}}
    _storage_{{lower}}::_ComponentStorage{ {{upper}} }
    {{/types}}
    _lock::UInt8
end

"""
    Query{{N}}{ {{joined}} }(world::World; with::Tuple{Vararg{DataType}}=(), without::Tuple{Vararg{DataType}}=())

Creates a query for {{N}} components.

# Arguments
- `with::Tuple{Vararg{DataType}}`: Additional components the entities must have.
- `without::Tuple{Vararg{DataType}}`: Components the entities must not have.
- `optional::Tuple{Vararg{DataType}}`: Makes components of the parameters optional.
"""
function Query{{N}}{ {{joined}} }(world::World;
        with::Tuple{Vararg{DataType}}=(),
        without::Tuple{Vararg{DataType}}=(),
        optional::Tuple{Vararg{DataType}}=()) where { {{joined}} }
    ids = (
        {{#types}}
        _component_id!(world, {{upper}}),
        {{/types}}
    )
    with_ids = map(x -> _component_id!(world, x), with)
    without_ids = map(x -> _component_id!(world, x), without)
    mask = _Mask(ids..., with_ids...)
    if length(optional) > 0
        opt_ids = map(x -> _component_id!(world, x), optional)
        mask = _clear_bits(mask, _Mask(opt_ids...))
    end
    return Query{{N}}{ {{joined}} }(
        0,
        world,
        ids,
        mask,
        _Mask(without_ids...),
        length(without_ids) > 0,
        {{#types}}
        _get_storage(world, ids[{{n}}], {{upper}}),
        {{/types}}
        0,
    )
end

"""
    get_components(q::Query{{N}}{ {{joined}} })::Tuple{ {{columns}} }

Returns the component columns of the archetype at the current cursor position.
"""
@inline function get_components(q::Query{{N}}{ {{joined}} })::Tuple{ {{columns}} } where { {{joined}} }
    return q[]
end

@inline function Base.getindex(q::Query{{N}}{ {{joined}} })::Tuple{ {{columns}} } where { {{joined}} }
    {{#types}}
    {{lower}} = q._storage_{{lower}}.data[q._index]
    {{/types}}
    return {{values}}
end

@inline function Base.iterate(q::Query{{N}}, state::Int)
    q._index = state
    while q._index <= length(q._world._archetypes)
        archetype = q._world._archetypes[q._index]
        if length(archetype.entities) > 0 && _contains_all(archetype.mask, q._mask) &&
                !(q._has_excluded && _contains_any(archetype.mask, q._exclude_mask))
            return q._index, q._index + 1
        end
        q._index += 1
    end
    close(q)
    return nothing
end

@inline function Base.iterate(q::Query{{N}})
    q._lock = _lock(q._world._lock)
    q._index = 1
    return Base.iterate(q, q._index)
end

"""
    close(q::Query{{N}})

Closes the query and unlocks the world.
Must be called if a query is not fully iterated.
"""
function close(q::Query{{N}})
    q._index = 0
    _unlock(q._world._lock, q._lock)
end

"""
    entities(q::Query{{N}})

Returns the entities of the current archetype
"""
function entities(q::Query{{N}})::Column{Entity}
    return q._world._archetypes[q._index].entities
end

{{/items}}