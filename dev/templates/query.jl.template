# ------------------------------------------------------------------------
# ⚠️ This file is auto-generated. DO NOT EDIT.
# Changes will be overwritten by the code generation process.
# ------------------------------------------------------------------------

{{#items}}
"""
    Query{{N}}{ {{joined}} }

A query for {{N}} components.
"""
mutable struct Query{{N}}{ {{joined}} }
    _index::Int
    _world::World
    _ids::Tuple{ {{tuple}} }
    _mask::_Mask
    {{#types}}
    _storage_{{lower}}::_ComponentStorage{ {{upper}} }
    {{/types}}
end

"""
    Query{{N}}{ {{joined}} }(world::World)

Creates a query for {{N}} components.
"""
function Query{{N}}{ {{joined}} }(world::World) where { {{joined}} }
    ids = (
        {{#types}}
        _component_id!(world, {{upper}}),
        {{/types}}
    )
    return Query{{N}}{ {{joined}} }(
        0,
        world,
        ids,
        _Mask(ids...),
        {{#types}}
        _get_storage(world, ids[{{n}}], {{upper}}),
        {{/types}}
    )
end

"""
    get_components(f::Query{{N}}{ {{joined}} })::Tuple{ {{columns}} }

Returns the component columns of the archetype at the current cursor position.
"""
@inline function get_components(f::Query{{N}}{ {{joined}} })::Tuple{ {{columns}} } where { {{joined}} }
    return f[]
end

@inline function Base.getindex(f::Query{{N}}{ {{joined}} })::Tuple{ {{columns}} } where { {{joined}} }
    {{#types}}
    {{lower}} = f._storage_{{lower}}.data[f._index]
    {{/types}}
    return {{values}}
end

@inline function Base.iterate(f::Query{{N}}, state::Int)
    f._index = state
    while f._index <= length(f._world._archetypes)
        archetype = f._world._archetypes[f._index]
        if _contains_all(archetype.mask, f._mask)
            return f._index, f._index + 1
        end
        f._index += 1
    end
    f._index = 0
    return nothing
end

@inline function Base.iterate(f::Query{{N}})
    f._index = 1
    return Base.iterate(f, f._index)
end

{{/items}}